
#region Help
# ----------

<#
	.SYNOPSIS
    
		Get-HyperVReport.ps1 (aka Hyper-V Environment Reporting Script) can be used to report Hyper-V Cluster or Standalone environments.

		Highlights:
			
			o Creates a plain but detailed and user-friendly HTML report which is compatible with all modern browsers.
			o Provides more detailed information via tooltips in the HTML report. (cells with asteriks and highlighted)
			o Checks and installs required runtime environment prerequisites like Hyper-V and Clustering Powershells.
			o Collects information by using standard Hyper-V and Clustering PowerShell cmdlets and custom WMI queries.
			o Shows alerts in the report for certain situations (utilizations, vm checkpoints, replication status, etc.)
			o Can be used directly from command-line or as a scheduled Windows task.
			o Supports report delivery via e-mail with advanced options. (authentication, TLS/SSL, multiple recipients)
			o Includes a mode that reports only alerts in the Hyper-V environment. (aka HighlightsOnly mode)
			o Advanced error handling and logging. (Console messages and log file)

		Version History:

			[x] Version 1.0 (Release) - 6.January.2015
			[ ] Version 0.9 (Preview) - 26.December.2014 *for a limited user group

		Requirements:

			o Hyper-V Targets (Clustered or Standalone)
				* Active Directory domain membership
				* Supported Operating Systems
					- Windows Server 2012
					- Windows Server 2012 R2
					- Hyper-V Server 2012
					- Hyper-V Server 2012 R2
			o Script Runtime Operating System (directly on a Hyper-V target or remote Windows operating system)
				* Same or trusted Active Directory domain membership with Hyper-V target
				* Supported Operating Systems 
					- Windows Server 2012
					- Windows Server 2012 R2
				* Windows PowerShell 3.0 or 4.0 (installed by default on supported operating systems)
				* Sets the Windows PowerShell execution policy to RemoteSigned or Unrestricted
				* Hyper-V PowerShell (if not, automatically installed by the Get-HyperVReport.ps1)
				* Failover Clustering PowerShell (if not, automatically installed by the Get-HyperVReport.ps1)
				* The script requires administrative privileges on the target Hyper-V server(s)

    .DESCRIPTION
 
		It can be difficult to monitor and assess resources in large Hyper-V environments. This script helps you to understand virtualization inventory, capacity and general resource availability in your Hyper-V environment. 

		Report details:
		
		1) Hyper-V Host (Clustered or Standalone):
        
			o Hostname
			o Operating System Version
			o State
			o Uptime
			o Domain Name
			o Total and Running VM Count
			o Processor Count
				* Logical processor count
				* Physical processor socket count
				* Hyper-Threading state for Intel processor (shown as tooltip)
			o Used Physical RAM
			o Free Physical RAM
			o Total Physical RAM

		2) Disk/Volume (Clustered or Standalone):

			o Name
				* Volume Name (Local Volume, Clustered Volume, Cluster Shared Volume)
				* Volume label or CSV path (shown as tooltip)
				* Disk name (Physical Disk, Clustered Disk)
				* Total/Allocated/Unallocated physical disk size (shown as tooltip)
			o Disk/Volume State
			o Usage (Logical Partition, Cluster Volume, Cluster Shared Volume, Quorum, System Volume)
			o Owner
			o Physical Disk Bus Type
			o Volume File System
			o Used Size
			o Free Size
			o Total Size

		3) Virtual Machine

			o Name
				* VM name 
				* Configuration XML path (shown as tooltip)
				* Generation
				* Version
			o State
			o Uptime
			o Owner
				* Owner hostname
			o Virtual Processor
				* Count
			o Virtual RAM
				* Startup
				* Minimum (if dynamic memory enabled)
				* Maximum (if dynamic memory enabled)
				* Assigned
			o Integration Services
				* State like UpToDate, UpdateRequired, MayBeRequired, NotDetected
				* Version number (shown as tooltip)
			o Checkpoint
				* Checkpoint state
				* Checkpoint count (if exists, shown as tooltip)
				* Checkpoint chain (if exists)
			o Replica
				* Replication State and Health
				* Replica Server (shown as tooltip)
				* Replication Frequency (shown as tooltip)
			o Disk
				* VHD Name
				* VHD File Path (shown as tooltip)
				* Current VHD file size
				* Maximum VHD disk size
				* VHD Type
				* Controller Type
				* VHD fragmentation percent
				* Including pass-trough disks (if exists)
				* Including differencing virtual disk chain (if exists)
				* Can detects missing VHD files (if exists)
			o Can detects clustered VM configuration resource problems like offline
			o Can detects clustered VM failed state

	.PARAMETER  Cluster
 
		A single Hyper-V Cluster name.
 
	.PARAMETER  VMHost
 
		A single standalone Hyper-V Host name or an array of standalone Hyper-V Host names.

	.PARAMETER  HighlightsOnly
 
		A filtering mode only allows the reporting of highlighted events and alerts.

	.PARAMETER  ReportFilePath
 
		HTML report file path. Script working directory is the default value.

	.PARAMETER  ReportFileNamePrefix
 
		HTML report file name prefix. The default value is "HyperVReport"

	.PARAMETER SendMail
 
		Send e-mail option ($true/$false). The default value is "$fale".

	.PARAMETER SMTPServer
 
		Mail server address.

	.PARAMETER SMTPPort
 
		Mail server port. The default value is "25".

	.PARAMETER MailTo
 
		A single mail recipient or an array of mail recipients.

	.PARAMETER MailFrom
 
		Mail sender address.

	.PARAMETER MailFromPassword
 
		Mail sender password for SMTP authentication.

	.PARAMETER SMTPServerTLSorSSL
 
		SMTP TLS/SSL option ($true/$false). The default value is "$fale".
		 
	.EXAMPLE

		Creates a Hyper-V Cluster report in the working directory.

		.\Get-HyperVReport.ps1 -Cluster Hvcluster1

	.EXAMPLE

		Creates a Hyper-V Cluster report that shown only highlighted events and alerts in the working directory.

		.\Get-HyperVReport.ps1 -Cluster Hvcluster1 -HighlightsOnly $true

	.EXAMPLE

		Creates one or more standalone Hyper-V Host(s) report in the working directory.

		.\Get-HyperVReport.ps1 -VMHost Host1,Host2,Host3

	.EXAMPLE

		Creates a Hyper-V Cluster report with custom file name prefix and saves is to the specified folder.

		.\Get-HyperVReport.ps1 -Cluster Hvcluster1 -ReportFileNamePrefix HvReport -ReportFilePath c:\tools
 
	.EXAMPLE

		Creates a Hyper-V Cluster report and sends it to multiple recipients as attachment without smtp authentication.

		.\Get-HyperVReport.ps1 -Cluster Hvcluster1 -SendMail $true -SMTPServer 10.29.0.50 -MailFrom sender@hyperv.corp -MailTo recepient1@hyperv.corp,recepient2@hyperv.corp

	.EXAMPLE

		Creates a Hyper-V Cluster report and sends it to multiple recipients as attachment with smtp authentication and TLS/SSL communication. -SMTPServerTLSorSSL is optional and used if forced by the smtp server.

		.\Get-HyperVReport.ps1 -Cluster Hvcluster1 -SendMail $true -SMTPServer 10.29.0.50 -MailFrom sender@hyperv.corp -MailFromPassword P@ssw0rd -SMTPServerTLSorSSL $true -MailTo recepient1@hyperv.corp,recepient2@hyperv.corp
 
	.INPUTS
 
		None
 
	.OUTPUTS
 
		None
 
	.NOTES
 
		Author: Serhat AKINCI
		Website: http://www.serhatakinci.com
		Email: serhatakinci@gmail.com
		Date created: 26.December.2014
		Last modified: 6.January.2015
		Version: 1.0
 
	.LINK
    
		http://www.serhatakinci.com (TR)
		https://twitter.com/serhatakinci
#>

#endregion Help

#region Script Parameters
# -----------------------

[CmdletBinding(SupportsShouldProcess=$True)]

Param (
    
    [parameter(
                Mandatory=$false,
                HelpMessage='Hyper-V Cluster name (like HvCluster1 or hvcluster1.domain.corp')]
               
                [string]$Cluster,

    [parameter(
                Mandatory=$false,
                HelpMessage='Standalone Hyper-V Host name(s) (like Host1, Host2, Host3)')]
               
                [array]$VMHost,

    [parameter(
                Mandatory=$false,
                HelpMessage='Only important events reports')]
               
                [bool]$HighlightsOnly = $false,
    
    [parameter(
                Mandatory=$false,
                HelpMessage='Disk path for HTML reporting file')]
               
                [string]$ReportFilePath = (Get-Location).path,

    [parameter(
                Mandatory=$false,
                HelpMessage='Name prefix for HTML reporting file')]
               
                [string]$ReportFileNamePrefix = "HyperVReport",

    [parameter(
                Mandatory=$false,
                HelpMessage='Enable Send Mail (This is just a switch, value can not be assigned)')]
               
                [bool]$SendMail = $false,

    [parameter(
                Mandatory=$false,
                HelpMessage='SMTP Server Address (Like IP address, hostname or FQDN)')]
            
                [string]$SMTPServer,

    [parameter(
                Mandatory=$false,
                HelpMessage='SMTP Server port number (Default 25)')]
            
                [int]$SMTPPort = "25",

    [parameter(
                Mandatory=$false,
                HelpMessage='Mail To (Recipient e-mail address)')]
               
                [array]$MailTo,

    [parameter(
                Mandatory=$false,
                HelpMessage='Mail From (Sender e-mail address)')]
               
                [string]$MailFrom,

    [parameter(
                Mandatory=$false,
                HelpMessage='For SMTP Authentication (Sender e-mail address password)')]
               
                [string]$MailFromPassword,

    [parameter(
                Mandatory=$false,
                HelpMessage='SMTP TLS/SSL option ($true/$false). The default is "$fale".')]
            
                [bool]$SMTPServerTLSorSSL = $false
)

#endregion Script Parameters

#region Functions
#----------------

# Get WMI data
function sGet-Wmi {

    param (

        [Parameter(Mandatory = $true)]
        [string]$ComputerName,
            
        [Parameter(Mandatory = $true)]
        [string]$Namespace,

        [Parameter(Mandatory = $true)]
        [string]$Class,

        [Parameter(Mandatory = $false)]
        $Property,

        [Parameter(Mandatory = $false)]
        $Filter,

        [Parameter(Mandatory = $false)]
        [switch]$AI

    )
    
    # Base string
    $wmiCommand = "gwmi -ComputerName $ComputerName -Namespace $Namespace -Class $Class -ErrorAction Stop"

    # If available, add Filter parameter
    if ($Filter)
    {
        # $Filter = ($Filter -join ',').ToString()
        $Filter = [char]34 + $Filter + [char]34
        $wmiCommand += " -Filter $Filter"
    }

    # If available, add Property parameter
    if ($Property)
    {
        $Property = ($Property -join ',').ToString()
        $wmiCommand += " -Property $Property"
    }

    # If available, Authentication and Impersonation
    if ($AI)
    {
        $wmiCommand += " -Authentication PacketPrivacy -Impersonation Impersonate"
    }

    # Try to connect
    $ResultCode = "1"
    Try
    {
        # $wmiCommand
        $wmiResult = iex $wmiCommand
    }
    Catch
    {
        $wmiResult = $_.Exception.Message
        $ResultCode = "0"
    }
    
    # If wmiResult is null
    if ($wmiResult -eq $null)
    {
        $wmiResult = "Result is null"
        $ResultCode = "2"
    }

    Return $wmiResult, $ResultCode
}

# Write Log
Function sPrint {

    param( 
        
        [byte]$Type=1,

        [string]$Message,
        
        [bool]$WriteToLogFile
        
    )

    $TimeStamp = Get-Date -Format "dd.MMM.yyyy HH:mm:ss"
    $Time = Get-Date -Format "HH:mm:ss"

    if ($Type -eq 1)
    {
        Write-Host "[INFO]    - $Time - $Message" -ForegroundColor Green

        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value "[INFO]    - $TimeStamp - $Message"
        }
    }
    elseif ($Type -eq 2)
    {
        Write-Host "[WARNING] - $Time - $Message" -ForegroundColor Yellow

        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value "[WARNING] - $TimeStamp - $Message"
        }
    }
    elseif ($Type -eq 5)
    {
        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value "[DEBUG]   - $TimeStamp - $Message"
        }
    }
        elseif ($Type -eq 6)
    {
        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value ""
        }
    }
    elseif ($Type -eq 0)
    {
        Write-Host "[ERROR]   - $Time - $Message" -ForegroundColor Red

        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value "[ERROR]   - $TimeStamp - $Message"
        }
    }
    else
    {
        Write-Host "[UNKNOWN] - $Time - $Message" -ForegroundColor Gray

        if (($WriteToLogFile) -and ($Logging))
        {
            Add-Content -Path $LogFile -Value "[UNKNOWN] - $TimeStamp - $Message"
        }
    }
}

# Convert Volume Size to KB/MB/GB/TB
Function sConvert-Size {

    param (
 
	# Disk or Volume Space
	[Parameter(Mandatory = $true)]
	$DiskVolumeSpace,

	# Disk or Volume Space Input Unit
	[Parameter(Mandatory = $true)]
	[string]$DiskVolumeSpaceUnit
 
    )

    if ($DiskVolumeSpaceUnit -eq "byte") # byte input
    {
        if (($DiskVolumeSpace -ge "1024") -and ($DiskVolumeSpace -lt "1048576"))
        {
            $DiskVolumeSpace =  [math]::round(($DiskVolumeSpace/1024))
            $DiskVolumeSpaceUnit = "KB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1048576") -and ($DiskVolumeSpace -lt "1073741824"))
        {
            $DiskVolumeSpace =  [math]::round(($DiskVolumeSpace/1024/1024))

            $DiskVolumeSpaceUnit = "MB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1073741824") -and ($DiskVolumeSpace -lt "1099511627776"))
        {
            $DiskVolumeSpace =  "{0:N1}" -f ($DiskVolumeSpace/1024/1024/1024)
            $DiskVolumeSpaceUnit = "GB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1099511627776") -and ($DiskVolumeSpace -lt "1125899906842624"))
        {
            $DiskVolumeSpace =  "{0:N2}" -f ($DiskVolumeSpace/1024/1024/1024/1024)
            $DiskVolumeSpaceUnit = "TB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        Else
        {
            $DiskVolumeSpace =  $DiskVolumeSpace
            $DiskVolumeSpaceUnit = "Byte"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }    
    }
    elseif ($DiskVolumeSpaceUnit -eq "kb") # kb input
    {
        if (($DiskVolumeSpace -ge "1") -and ($DiskVolumeSpace -lt "1024"))
        {
            $DiskVolumeSpace =  $DiskVolumeSpace
            $DiskVolumeSpaceUnit = "KB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1024") -and ($DiskVolumeSpace -lt "1048576"))
        {
            $DiskVolumeSpace =  ($DiskVolumeSpace/1024)
            $DiskVolumeSpaceUnit = "MB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1048576") -and ($DiskVolumeSpace -lt "1073741824"))
        {
            $DiskVolumeSpace =  "{0:N1}" -f ($DiskVolumeSpace/1024/1024)
            $DiskVolumeSpaceUnit = "GB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1073741824") -and ($DiskVolumeSpace -lt "1099511627776"))
        {
            $DiskVolumeSpace =  "{0:N2}" -f ($DiskVolumeSpace/1024/1024/1024)
            $DiskVolumeSpaceUnit = "TB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        Else
        {
            $DiskVolumeSpace =  $DiskVolumeSpace
            $DiskVolumeSpaceUnit = "KB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }    
    }
    elseif ($DiskVolumeSpaceUnit -eq "mb") # mb input
    {
        if (($DiskVolumeSpace -ge "1") -and ($DiskVolumeSpace -lt "1024"))
        {
            $DiskVolumeSpace =  $DiskVolumeSpace
            $DiskVolumeSpaceUnit = "MB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1024") -and ($DiskVolumeSpace -lt "1048576"))
        {
            $DiskVolumeSpace =  "{0:N1}" -f ($DiskVolumeSpace/1024)
            $DiskVolumeSpaceUnit = "GB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        elseif (($DiskVolumeSpace -ge "1048576") -and ($DiskVolumeSpace -lt "1073741824"))
        {
            $DiskVolumeSpace =  "{0:N2}" -f ($DiskVolumeSpace/1024/1024)
            $DiskVolumeSpaceUnit = "TB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }
        Else
        {
            $DiskVolumeSpace =  $DiskVolumeSpace
            $DiskVolumeSpaceUnit = "MB"
            return $DiskVolumeSpace, $DiskVolumeSpaceUnit
        }    
    }
    else
    {
        return "Unknown Parameter"
    }
}

# Convert BusType Value to BusType Name
Function sConvert-BusTypeName {
    
    Param ([Byte] $BusTypeValue)
    
    if ($BusTypeValue -eq 1){$Result = "SCSI"}
    elseif ($busTypeValue -eq 2){$Result = "ATAPI"}
    elseif ($busTypeValue -eq 3){$Result = "ATA"}
    elseif ($busTypeValue -eq 4){$Result = "IEEE 1394"}
    elseif ($busTypeValue -eq 5){$Result = "SSA"}
    elseif ($busTypeValue -eq 6){$Result = "FC"}
    elseif ($busTypeValue -eq 7){$Result = "USB"}
    elseif ($busTypeValue -eq 8){$Result = "RAID"}
    elseif ($busTypeValue -eq 9){$Result = "iSCSI"}
    elseif ($busTypeValue -eq 10){$Result = "SAS"}
    elseif ($busTypeValue -eq 11){$Result = "SATA"}
    elseif ($busTypeValue -eq 12){$Result = "SD"}
    elseif ($busTypeValue -eq 13){$Result = "SAS"}
    elseif ($busTypeValue -eq 14){$Result = "Virtual"}
    elseif ($busTypeValue -eq 15){$Result = "FB Virtual"}
    elseif ($busTypeValue -eq 16){$Result = "Storage Spaces"}
    elseif ($busTypeValue -eq 17){$Result = "NVMe"}
    else {$Result = "Unknown"}

    Return $Result
}

# Convert Cluster Disk State Value to Name
Function sConvert-ClusterDiskState {
    
    Param ([Byte] $StateValue)

    if ($StateValue -eq 0){$Result = "Inherited",$stateBgColors[5],$stateWordColors[5]}
    elseif ($StateValue -eq 1){$Result = "Initializing",$stateBgColors[4],$stateWordColors[4]}
    elseif ($StateValue -eq 2){$Result = "Online",$stateBgColors[1],$stateWordColors[1]}
    elseif ($StateValue -eq 3){$Result = "Offline",$stateBgColors[2],$stateWordColors[2]}
    elseif ($StateValue -eq 4){$Result = "Failed",$stateBgColors[3],$stateWordColors[3]}
    elseif ($StateValue -eq 127){$Result = "Offline",$stateBgColors[2],$stateWordColors[2]}
    elseif ($StateValue -eq 128){$Result = "Pending",$stateBgColors[4],$stateWordColors[4]}
    elseif ($StateValue -eq 129){$Result = "Online Pending",$stateBgColors[4],$stateWordColors[4]}
    elseif ($StateValue -eq 130){$Result = "Offline Pending",$stateBgColors[4],$stateWordColors[4]}  
    else {$Result = "Unknown",$stateBgColors[5],$stateWordColors[5]} # Including "-1" state

    Return $Result
}

# Convert BusType Value to BusType Name
Function sConvert-DiskPartitionStyle {
    
    Param ([Byte] $PartitionStyleValue)
    
    if ($PartitionStyleValue -eq 1)
    {
        $Result = "MBR"
    }
    elseif ($PartitionStyleValue -eq 2)
    {
        $Result = "GPT"
    }
    else 
    {
        $Result = "Unknown"
    }

    Return $Result
}

# Generate Volume Size Colors
Function sConvert-VolumeSizeColors {

    Param ([Byte] $FreePercent)

    if (($FreePercent -le 10) -and ($FreePercent -gt 5))
    {
        $Result = $stateBgColors[4],$stateBgColors[4],$stateWordColors[4]
    }
    elseif ($FreePercent -le 5)
    {
        $Result = $stateBgColors[3],$stateBgColors[3],$stateWordColors[3]
    }
    else
    {
        $Result = $stateBgColors[0],$stateBgColors[0],$stateWordColors[0]
    }

    Return $Result
}

#endregion Functions

#region Variables
#----------------

# Print MSG
sPrint -Type 1 -Message "Started! Hyper-V Environment Reporting Script (Version 1.0)"
Start-Sleep -Seconds 3

# State Colors
[array]$stateBgColors = "", "#ACFA58","#E6E6E6","#FB7171","#FBD95B","#BDD7EE" #0-Null, 1-Online(green), 2-Offline(grey), 3-Failed/Critical(red), 4-Warning(orange), 5-Other(blue)
[array]$stateWordColors = "", "#298A08","#848484","#A40000","#9C6500","#204F7A","#FFFFFF" #0-Null, 1-Online(green), 2-Offline(grey), 3-Failed/Critical(red), 4-Warning(orange), 5-Other(blue), 6-White

# Date and Time
$Date = Get-Date -Format d/MMM/yyyy
$Time = Get-Date -Format "hh:mm:ss tt"

# Log and report file/folder
$FileTimeSuffix = ((Get-Date -Format dMMMyy).ToString()) + "-" + ((get-date -Format hhmmsstt).ToString())
$ReportFile = $ReportFilePath + "\" + $ReportFileNamePrefix + "-" + $FileTimeSuffix + ".html"
$LogFile = $ReportFilePath + "\" + "ScriptLog" + ".txt"

# Logging enabled
[bool]$Logging = $True

# HighlightsOnly Mode String
$hlString = $null
if ($HighlightsOnly)
{
    $hlString = "<center><span style=""padding-top:1px;padding-bottom:1px;font-size:12px;background-color:#FBD95B;color:#FFFFFF"">&nbsp;(HighlightsOnly Mode)&nbsp;</span></center>"
    sPrint -Type 1 -Message "HighlightsOnly mode is enabled." -WriteToLogFile $True
}


#endregion Variables

#region Prerequisities Check
#---------------------------

# Log file check and write subject line
if (!(Test-Path -Path $LogFile)) {

    New-Item -Path $LogFile -ItemType file -Force -ErrorAction SilentlyContinue | Out-Null
    
    if (Test-Path -Path $LogFile)
    {
        sPrint -Type 6 -WriteToLogFile $true
        sPrint -Type 5 -Message "----- Start -----" -WriteToLogFile $true
        sPrint -Type 1 -Message "Logging started: $LogFile" -WriteToLogFile $True
        Start-Sleep -Seconds 3
    }
    else
    {
        $Logging = $false
        sPrint -Type 2 -Message "Unable to create the log file. Script will continue without logging..."
        Start-Sleep -Seconds 3
    }
}
else {

    sPrint -Type 6 -WriteToLogFile $true
    sPrint -Type 5 -Message "----- Start -----" -WriteToLogFile $true
    sPrint -Type 1 -Message "Logging started: $LogFile" -WriteToLogFile $true
    Start-Sleep -Seconds 3
}

# Controls for some important prerequisites
if ((!$VMHost) -and (!$Cluster)) {

    sPrint -Type 0 -Message "Hyper-V target parameter is missing. Use -Cluster or -VMHost parameter to define target." -WriteToLogFile $True
    sPrint -Type 2 -Message "For technical information, type: Get-Help .\Get-HyperVReport.ps1 -examples" -WriteToLogFile $True
    sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
    Break
}
if (($VMHost) -and ($Cluster)) {

    sPrint -Type 0 -Message "-Cluster and -VMHost parameters can not be used together." -WriteToLogFile $True
    sPrint -Type 2 -Message "For technical information, type: Get-Help .\Get-HyperVReport.ps1 -examples" -WriteToLogFile $True
    sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
    Break
}

# Controls for runtime environment operating system version, Hyper-V PowerShell and Clustering PowerShell modules
sPrint -Type 1 -Message "Checking prerequisites to run script on the $($env:COMPUTERNAME.ToUpper())..." -WriteToLogFile $True
$osVersion = $null
$osName = $null
$osVersion = sGet-Wmi -ComputerName $env:COMPUTERNAME -Namespace root\Cimv2 -Class Win32_OperatingSystem -Property Version,Caption
    
    if ($osVersion[1] -eq 1)
    {
        $osName = $osVersion[0].Caption
        $osVersion = $osVersion[0].Version
    }
    else
    {
        sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): $($osVersion[0])" -WriteToLogFile $True
        sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
        Break
    }

    if ($osVersion)
    {
        if (($OsVersion -like "6.2*") -or ($OsVersion -like "6.3*"))
        {
            if ($osName -like "Microsoft Windows 8*")
            {
                sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): Windows client-based operating system is not supported as script runtime OS." -WriteToLogFile $True
                sPrint -Type 2 -Message "For technical information, type: Get-Help .\Get-HyperVReport.ps1" -WriteToLogFile $True
                sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
                Break
            }
            else
            {
                sPrint -Type 5 -Message "$($env:COMPUTERNAME.ToUpper()): Operating system is supported." -WriteToLogFile $True

                # Check Hyper-V PowerShell
                if ((Get-WindowsFeature -ComputerName $env:COMPUTERNAME -Name "Hyper-V-PowerShell").Installed)
                {
                    sPrint -Type 5 -Message "$($env:COMPUTERNAME.ToUpper()): Hyper-V PowerShell Module is OK." -WriteToLogFile $True
                }
                else
                {
                    sPrint -Type 2 -Message "$($env:COMPUTERNAME.ToUpper()): Hyper-V PowerShell Module is not found." -WriteToLogFile $True
                    sPrint -Type 2 -Message "$($env:COMPUTERNAME.ToUpper()): Installing Hyper-V PowerShell Module... " -WriteToLogFile $True
                    Start-Sleep -Seconds 3
                    Add-WindowsFeature -Name "Hyper-V-PowerShell" -ErrorAction SilentlyContinue | Out-Null

                    if ((Get-WindowsFeature -ComputerName $env:COMPUTERNAME -Name "Hyper-V-PowerShell").Installed)
                    {
                        sPrint -Type 1 -Message "$($env:COMPUTERNAME.ToUpper()): Hyper-V PowerShell Module is OK." -WriteToLogFile $True
                    }
                    else
                    {
                        sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): Hyper-V PowerShell Module could not be installed. Please install it manually." -WriteToLogFile $True
                        sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
                        Break
                    }
                }
            
                # Check Failover Cluster PowerShell
                if ($Cluster)
                {
                    if ((Get-WindowsFeature -ComputerName $env:COMPUTERNAME -Name "RSAT-Clustering-PowerShell").Installed)
                    {
                        sPrint -Type 5 -Message "$($env:COMPUTERNAME.ToUpper()): Failover Clustering PowerShell Module is OK." -WriteToLogFile $True
                    }
                    else
                    {
                        sPrint -Type 2 -Message "$($env:COMPUTERNAME.ToUpper()): Failover Clustering PowerShell Module is not found." -WriteToLogFile $True
                        sPrint -Type 2 -Message "$($env:COMPUTERNAME.ToUpper()): Installing Failover Clustering PowerShell Module..." -WriteToLogFile $True
                        Start-Sleep -Seconds 3
                        Add-WindowsFeature -Name "RSAT-Clustering-PowerShell" | Out-Null

                        if ((Get-WindowsFeature -ComputerName $env:COMPUTERNAME -Name "RSAT-Clustering-PowerShell").Installed)
                        {
                            sPrint -Type 1 -Message "$($env:COMPUTERNAME.ToUpper()): Failover Clustering PowerShell Module is OK." -WriteToLogFile $True
                        }
                        else
                        {
                            sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): Failover Clustering PowerShell Module could not be installed. Please install it manually." -WriteToLogFile $True
                            sPrint -Type 0 -Message "Script terminated!"
                            Break
                        }
                    }
                }
            }
        }
        else
        {
            sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): Incompatible operating system version detected. Supported operating systems are Windows Server 2012 and Windows Server 2012 R2." -WriteToLogFile $True
            sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
            Break
        }    
    }
    else
    {
        sPrint -Type 0 -Message "$($env:COMPUTERNAME.ToUpper()): Could not detect operating system version." -WriteToLogFile $True
        sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
        Break
    }

$Computers = $null
$ClusterName = $null
[array]$VMHosts = $null

#endregion Prerequisities Check

#region HTML Start
#----------------

# HTML Head
$outHtmlStart = "<html>
<head>
<title>Hyper-V Environment Report</title>
<style>
/*Reset CSS*/
html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, 
time, mark, audio, video {margin: 0;padding: 0;border: 0;font-size: 100%;font: inherit;vertical-align: baseline;}
ol, ul {list-style: none;}
blockquote, q {quotes: none;}
blockquote:before, blockquote:after,
q:before, q:after {content: '';content: none;}
table {border-collapse: collapse;border-spacing: 0;}
/*Reset CSS*/

body{
    width:100%;
    min-width:1024px;
    font-family: Verdana, sans-serif;
    font-size:14px;
    /*font-weight:300;*/
    line-height:1.5;
    color:#222222;
    background-color:#fcfcfc;
}

p{
    color:222222;
}

strong{
    font-weight:600;
}

h1{
    font-size:30px;
    font-weight:300;
}

h2{
    font-size:20px;
    font-weight:300;
}

#ReportBody{
    width:95%;
    height:500;
    /*border: 1px solid;*/
    margin: 0 auto;
}

.VMHosts{
    width:100%;
    /*height:200px;*/
    /*border: 1px solid;*/
    float:left;
    margin-bottom:30px;
}

table#VMHosts-Table tr:nth-child(odd){
    background:#F9F9F9;
}

table#Disks-Volumes-Table tr:nth-child(odd){
    background:#F9F9F9;
}

.Disks-Volumes{
    width:100%;
    /*height:400px;*/
    /*border: 1px solid;*/
    float:left;
    margin-bottom:30px;
}

.VMs{
    width:100%;
    /*height:200px;*/
    /*border: 1px solid;*/
    float:left;
    margin-bottom:22px;
    line-height:1.5;
}

table{
    width:100%;
    min-width:1010px;
    /*table-layout: fixed;*/
    border-collapse: collapse;
    border: 1px solid #ccc;
    /*margin-bottom:15px;*/
}

/*Row*/
tr{
    font-size: 12px;
}

/*Column*/
td {
    padding:10px 8px 10px 8px;
    font-size: 12px;
    border: 1px solid #ccc;
    text-align:center;
    vertical-align:middle;
}

/*Table Heading*/
th {
    background: #f3f3f3;
    border: 1px solid #ccc;
    font-size: 14px;
    font-weight:normal;
    padding:12px;
    text-align:center;
    vertical-align:middle;
}
</style>
</head>
<body>
<br/><br/>
<center><h1>Hyper-V Environment Report</h1></center>
<center><font face=""Verdana,sans-serif"" size=""3"" color=""#222222"">Generated on $($Date) at $($Time)</font></center>
$($hlString)
<br/>
<div id=""ReportBody""><!--Start ReportBody-->"

#endregion

#region Gathering Hyper-V Host Information
#-----------------------------------------
    
if ($Cluster) {
    
    if (($Cluster -eq "localhost") -or ($Cluster -eq "127.0.0.1"))
    {
        $ClusterName = $env:COMPUTERNAME
    }
    else
    {
        $ClusterName = $Cluster
    }
    
    $ClusterNodes = $null

    if (Get-Cluster -Name $ClusterName -ErrorAction SilentlyContinue)
    {
        $ClusterName = (Get-Cluster -Name $ClusterName).Name
        $hostTableCaption = "Cluster Nodes <span style=""font-size:16px;color:#BDBDBD"">($($ClusterName))</span>"
        $volumeTableCaption = "Clustered Disks/Volumes"

        sPrint -Type 1 -Message "$($ClusterName.ToUpper()) is accessible. Gathering Node information..." -WriteToLogFile $True
        Start-Sleep -Seconds 3

        sPrint -Type 1 -Message "Checking prerequisites for Hyper-V Cluster reporting..." -WriteToLogFile $True
        Start-Sleep -Seconds 3

        $clusterNodesData = Get-ClusterNode -Cluster $ClusterName -ErrorAction SilentlyContinue | select Name,State
        $ClusterNodes = ($clusterNodesData | where{$_.State -ne "Down"}).Name
        $downClusterNodes = ($clusterNodesData | where{$_.State -eq "Down"}).Name

        if ($downClusterNodes)
        {
            sPrint -Type 0 "Unavailable or down Hyper-V Cluster Node(s): $downClusterNodes" -WriteToLogFile $True
            Start-Sleep -Seconds 3
        }

        if ($ClusterNodes)
        {
            # Checking Cluster Owner Node OS version and Hyper-V role
            $clusterOwnerHostName = sGet-Wmi -ComputerName $ClusterName -Namespace root\Cimv2 -Class  Win32_ComputerSystem -Property Name
            if ($clusterOwnerHostName[1] -eq 1)
            {
                $clusterOwnerHostName = $clusterOwnerHostName[0].Name
            }
            else
            {
                sPrint -Type 0 -Message "$ClusterName`: $($clusterOwnerHostName[0])" -WriteToLogFile $True
                sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
                Break
            }
            
            $osVersion = $null
            $getClusterOwnerNode = Get-ClusterNode -Cluster $ClusterName -Name $clusterOwnerHostName
            $osVersion = ($getClusterOwnerNode.MajorVersion).ToString() + "." + ($getClusterOwnerNode.MinorVersion).ToString()
            if (($osVersion -like "6.2") -or ($osVersion -like "6.3"))
            {
                if ((Get-WindowsFeature -ComputerName $clusterOwnerHostName -Name "Hyper-V").Installed)
                {
                    sPrint -Type 5 -Message "Operating system version and Hyper-V role on the cluster owner node is OK." -WriteToLogFile $True
                    $VMHosts = $ClusterNodes
                }
                else
                {
                    sPrint -Type 2 -Message "Hyper-V role is not installed on $clusterOwnerHostName." -WriteToLogFile $True
                    sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
                    Break
                }
            }
            else
            {
                sPrint -Type 2 -Message "$($ClusterName.ToUpper()): Incompatible operating system version detected. Supported operating systems are Windows Server 2012 and Windows Server 2012 R2." -WriteToLogFile $True
                sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
                Break
            }
        }
        else
        {
            sPrint -Type 0 -Message "$ClusterName`: $($error[0].Exception.Message)" -WriteToLogFile $True
            sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
            Break
        }
    }
    else
    {
        sPrint -Type 0 -Message "$($ClusterName.ToUpper()): $($error[0].Exception.Message)" -WriteToLogFile $True
        sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
        Break
    }
}
    
if ($VMHost) {

    if (($Cluster -eq "localhost") -or ($Cluster -eq "127.0.0.1"))
    {
        $Computers = $env:COMPUTERNAME
    }
    else
    {
        $Computers = $VMHost | Sort-Object -Unique
    }

    [array]$invalidVmHost = $null
    [array]$invalidVmHostMsg = $null
    $hostTableCaption = "Standalone Host(s)"
    $volumeTableCaption = "Local Disks/Volumes"

    sPrint -Type 1 -Message "Checking prerequisites for standalone Hyper-V host(s) reporting..." -WriteToLogFile $True
    Start-Sleep -Seconds 3

    foreach ($ComputerName in $Computers)
    {
        $osVersion = $null
        $osVersion = sGet-Wmi -ComputerName $ComputerName -Namespace root\Cimv2 -Class Win32_OperatingSystem -Property Version
        
        if ($osVersion[1] -eq 1)
        {
            $osVersion = $osVersion[0].Version
        }
        else
        {
            sPrint -Type 0 -Message "$($ComputerName.ToUpper()): $($osVersion[0])" -WriteToLogFile $True
            Start-Sleep -Seconds 3
            $invalidVmHost += $ComputerName
            $invalidVmHostMsg += $osVersion[0]
            Continue
        }

        if ($OsVersion)
        {
            if (($OsVersion -like "6.2*") -or ($OsVersion -like "6.3*"))
            {
                if ((Get-WindowsFeature -ComputerName $ComputerName -Name "Hyper-V").Installed)
                {
                    $checkClusterMember = sGet-Wmi -ComputerName $ComputerName -Namespace root\MSCluster -Class MSCluster_Cluster -Property Name
                    if ($checkClusterMember[1] -eq 1)
                    {
                        sPrint -Type 0 -Message "$($ComputerName.ToUpper()) is a member of a Hyper-V Cluster and didn't included in the VMHost list. Please use -Cluster parameter to report this node." -WriteToLogFile $True
                        $invalidVmHost += $ComputerName
                        $invalidVmHostMsg += "This Node is a member of a cluster. Please use -Cluster parameter to report this node."
                    }
                    else
                    {
                        sPrint -Type 5 -Message "$($ComputerName.ToUpper()): Operating system version and Hyper-V role is OK." -WriteToLogFile $True
                        $VMHosts += $ComputerName
                    }
                }
                else
                {
                    sPrint -Type 0 -Message "$($ComputerName.ToUpper()): Could not be added to the VMHost list because Hyper-V role is not installed." -WriteToLogFile $True
                    $invalidVmHost += $ComputerName
                    $invalidVmHostMsg += "Could not be added to the VMHost list because Hyper-V role is not installed"
                }
            }
            else
            {
                sPrint -Type 0 -Message "$($ComputerName.ToUpper()): Could not be added to the VMHost list because incompatible operating system version detected." -WriteToLogFile $True
                $invalidVmHost += $ComputerName
                $invalidVmHostMsg += "Could not be added to the VMHost list because incompatible operating system version detected"
            }            
        }
        else
        {
            sPrint -Type 0 -Message "$($ComputerName.ToUpper()): Could not be added to the VMHost list because operating system version could not be detected." -WriteToLogFile $True
            $invalidVmHost += $ComputerName
            $invalidVmHostMsg += "Could not be added to the VMHost list because operating system version could not be detected"
        }
    }
}

if (!$VMHosts) {

    sPrint -Type 2 "No valid server for reporting." -WriteToLogFile $True
    sPrint -Type 0 -Message "Script terminated!" -WriteToLogFile $True
    Break
}
else {
    
    if ($Cluster)
    {
        sPrint -Type 1 "Available Hyper-V Cluster Node(s) for reporting: $VMHosts" -WriteToLogFile $True
        Start-Sleep -Seconds 3
    }
    else
    {
        sPrint -Type 1 "Available Hyper-V server(s) for reporting: $VMHosts" -WriteToLogFile $True
        Start-Sleep -Seconds 3
    }
}

# Print MSG
sPrint -Type 1 "Gathering Hyper-V Host information..." -WriteToLogFile $True

# VMHosts-Table Header
    $outVMHostTableStart ="
    <div class=""VMHosts""><!--Start VMHosts Class-->
        <h2>$($hostTableCaption)</h2><br>
        <table id=""VMHosts-Table"">
        <tbody>
            <tr><!--Header Line-->
                <th><p style=""text-align:left;margin-left:-4px"">Name</p></th>
                <th><p>State</p></th>
                <th><p>Uptime</p></th>
                <th><p>Domain</p></th>
                <th><p style=""line-height:1.2"">Total <br/>VM</p></th>
                <th><p style=""line-height:1.2"">Logical <br/>Processor</p></th>
                <th><p style=""line-height:1.2"">Used <br/>RAM</p></th>
                <th><p style=""line-height:1.2"">Free <br/>RAM</p></th>
                <th><p style=""line-height:1.2"">Total <br/>RAM</p></th>
            </tr>"

# Generate Data Lines
$outVMHostTable = $null
foreach ($vmHostItem in $vmHosts) {

    $highL = $false
    $chargerVMHostTable = $null
    $vmHostData = $null
    $vmHostGet = Get-VMHost -ComputerName $vmHostItem
    $vmHostVMs = Get-VM -ComputerName $vmHostItem
    $vmHostVmCount = ($vmHostVMs).Count
    $vmHostRunningVmCount = ($vmHostVMs | where{$_.State -eq "Running"}).Count
    $vmHostWmiData = Get-WmiObject -ComputerName $vmHostItem -Class Win32_OperatingSystem

    # State
    if ($Cluster)
    {
        $vmHostState = (Get-ClusterNode -Cluster $ClusterName -Name $vmHostItem).State
    }
    else
    {
        $vmHostState = "Up"  
    }

    # State Colors
    if ($vmHostState -eq "Up")
    {
        $outVmHostState = "Up",$stateBgColors[1],$stateWordColors[1]
    }
    elseif ($vmHostState -eq "Down")
    {
        $outVmHostState = "Down",$stateBgColors[3],$stateWordColors[3]
        $highL = $true
    }
    elseif ($vmHostState -eq "Paused")
    {
        $outVmHostState = "Paused",$stateBgColors[2],$stateWordColors[2]
    }
    elseif ($vmHostState -eq "Joining")
    {
        $outVmHostState = "Joining",$stateBgColors[4],$stateWordColors[4]
    }
    else
    {
        $outVmHostState = "Unknown",$stateBgColors[5],$stateWordColors[5]
        $highL = $true
    }
    
    # Clear
    $TotalUsedMemory = $null
    $TotalFreeMemory = $null
    $TotalVisibleMemory = $null
    $vmHostUptime = $null
    $TotalFreeMemoryPercentage = $null
     
    # Memory Capacty
    $TotalUsedMemory = sConvert-Size -DiskVolumeSpace ($vmHostWmiData.TotalVisibleMemorySize - $vmHostWmiData.FreePhysicalMemory) -DiskVolumeSpaceUnit kb
    $TotalFreeMemory = sConvert-Size -DiskVolumeSpace $vmHostWmiData.FreePhysicalMemory -DiskVolumeSpaceUnit kb
    $TotalVisibleMemory = sConvert-Size -DiskVolumeSpace $vmHostWmiData.TotalVisibleMemorySize -DiskVolumeSpaceUnit kb
    $TotalFreeMemoryPercentage = [math]::round(($vmHostWmiData.FreePhysicalMemory/$vmHostWmiData.TotalVisibleMemorySize)*100)

    # Free Memory Percentage Colors
    # 0 - $totalFreeMemoryBgColor
    # 1 - $TotalFreeMemoryPercentageBgColor
    # 2 - $TotalFreeMemoryPercentageWordColor
    if (($TotalFreeMemoryPercentage -le 10) -and ($TotalFreeMemoryPercentage -gt 5))
    {
        $outVmHostFreeMemoryState = $stateBgColors[4],$stateBgColors[4],$stateWordColors[4]
        $highL = $true
    }
    elseif ($TotalFreeMemoryPercentage -le 5)
    {
        $outVmHostFreeMemoryState = $stateBgColors[3],$stateBgColors[3],$stateWordColors[3]
        $highL = $true
    }
    else
    {
        $outVmHostFreeMemoryState = $stateBgColors[0],$stateBgColors[0],"#BDBDBD"
    }

    # Hostname
    $outVMHostName = ($vmHostGet.ComputerName).ToUpper()
     
    # Uptime
    $vmHostUptime = ([Management.ManagementDateTimeConverter]::ToDateTime($vmHostWmiData.LocalDateTime)) - ([Management.ManagementDateTimeConverter]::ToDateTime($vmHostWmiData.LastBootUpTime))
        if($vmHostUptime.Days -eq "0"){$vmHostUptimeDays = ""}
        else{$vmHostUptimeDays = ($vmHostUptime.Days).ToString() + " <span style=""font-size:10px;color:#BDBDBD"">Days</span> <br/>"}
    $vmHostUptime = ($vmHostUptime.Hours).ToString() + ":" + ($vmHostUptime.Minutes).ToString() + ":" + ($vmHostUptime.Seconds).ToString()

    # OS Version
    $vmHostOsVersion = ($vmHostWmiData.Caption).Replace("Microsoft ","")

    # Processor socket and HT state
    $processorData = sGet-Wmi -ComputerName $vmHostItem -Namespace root\CIMv2 -Class win32_processor -Property DeviceID,NumberOfCores,NumberOfLogicalProcessors
    if ($processorData[1] -eq 1)
    {
        $socketCount = ($processorData[0] | ForEach-Object {$_.DeviceID} | select-object -unique).Count
        $coreCount = ($processorData[0].NumberOfCores | Measure-Object -Sum).Sum
        $logicalProcCount = ($processorData[0].NumberOfLogicalProcessors | Measure-Object -Sum).Sum

        if ($logicalProcCount -gt $coreCount)
        {
            $htState = "Active"
        }
        Else
        {
            $htState = "Inactive"
        }
    }
    else
    {
        $socketCount = "-"
        $htState = "Unknown"
    }

    $vmHostLpCount = $vmHostGet.LogicalProcessorCount
    if (!$vmHostLpCount)
    {
        $vmHostLpCount = $logicalProcCount
    }

    # Data Line
    $chargerVMHostTable ="
            <tr><!--Data Line-->
                <td><p style=""text-align:left;"">$($outVMHostName)<br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">$($vmHostOsVersion)</span></p></td>
                <td bgcolor=""$($outVmHostState[1])""><p style=""color:$($outVmHostState[2])"">$($outVmHostState[0])</p></td>
                <td><p>$($vmHostUptimeDays)$($vmHostUptime)</p></td>
                <td><p>$($vmHostGet.FullyQualifiedDomainName)</p></td>
                <td><p style=""line-height:1.2"">$($vmHostVmCount) <br/><span style=""font-size:10px;color:#BDBDBD""><abbr title=""Total Running VMs on the $($outVMHostName)"">$($vmHostRunningVmCount) Running <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td><p style=""line-height:1.2"">$($vmHostLpCount) <br/><span style=""font-size:10px;color:#BDBDBD""><abbr title=""Hyper-Threading: $($htState)"">$($socketCount) Socket <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td><p style=""line-height:1.2"">$(($TotalUsedMemory)[0])<br/><span style=""font-size:10px"">$(($TotalUsedMemory)[1])</span></p></td>
                <td bgcolor=""$($outVmHostFreeMemoryState[0])""><p style=""line-height:1.2"">$(($TotalFreeMemory)[0])<br/><span style=""font-size:10px"">$(($TotalFreeMemory)[1])</span></p></td>
                <td><p style=""line-height:1.2"">$(($TotalVisibleMemory)[0]) <span style=""font-size:10px"">$(($TotalVisibleMemory)[1])</span> <br/><span style=""font-size:10px;background-color:$($outVmHostFreeMemoryState[1]);color:$($outVmHostFreeMemoryState[2])"">&nbsp;~%$($TotalFreeMemoryPercentage) free&nbsp;</span></p></td>
            </tr>"

    # Add to HTML Table
    if ($HighlightsOnly -eq $false)
    {
        # VMHost Output
        $outVMHostTable += $chargerVMHostTable
    }
    elseif (($HighlightsOnly -eq $true) -and ($highL -eq $true))
    {
        # VMHost Output
        $outVMHostTable += $chargerVMHostTable
    }
    else
    {
        # Blank
    }
}

# Add offline or unsupported standalone hosts
if ($invalidVmHost)
{
    [bytle]$numb = 0
    ForEach ($VMhostIN in $invalidVmHost)
    {

    $outVMHostTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left;"">$(($VMhostIN).ToUpper())<br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Operating System Unknown</span></p></td>
                <td bgcolor=""$($stateBgColors[2])""><p style=""color:$($stateWordColors[2])"">Unaccessible</p></td>
                <td colspan=""7""><p style=""text-align:left; color:#BDBDBD"">$($invalidVmHostMsg[$numb])</p></td>
            </tr>"
    
    $numb = $numb + 1

    }
}

# Add down cluster nodes
if ($downClusterNodes)
{
    ForEach ($downClusterNode in $downClusterNodes)
    {

    $outVMHostTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left;"">$($downClusterNode)<br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Operating System Unknown</span></p></td>
                <td bgcolor=""$($stateBgColors[3])""><p style=""color:$($stateWordColors[3])"">Down</p></td>
                <td colspan=""7""><p style=""text-align:left; color:#BDBDBD"">Hyper-V Cluster node is down or unavailable</p></td>
            </tr>"
    }
}

if (($outVMHostTable -eq $null) -and ($downClusterNodes -eq $null))
{
    if ($Cluster)
    {
        $outVMHostTable +="
            <tr><!--Data Line-->
                <td colspan=""9""><p style=""text-align:center""><span style=""padding-top:1px;padding-bottom:1px;background-color:#ACFA58;color:#298A08"">&nbsp;&nbsp;All Hyper-V Cluster Nodes are healthy&nbsp;&nbsp;</span></p></td>
            </tr>"
    }
    else
    {
        $outVMHostTable +="
            <tr><!--Data Line-->
                <td colspan=""9""><p style=""text-align:center""><span style=""padding-top:1px;padding-bottom:1px;background-color:#ACFA58;color:#298A08"">&nbsp;All Standalone Hyper-V Hosts are healthy&nbsp;&nbsp;</span></p></td>
            </tr>"
    }
}

    # End VMHosts-Table
    $outVMHostTableEnd ="
        </tbody>
        </table>
    </div><!--End VMHosts Class-->"

#endregion

#region Gathering Disk/Volume Information
#----------------------------------------

# Print MSG
sPrint -Type 1 "Gathering Disk/Volume information..." -WriteToLogFile $True

# Disks-Volumes-Table Header
    $outVolumeTableStart += "
    <div class=""Disks-Volumes""><!--Start Disks-Volumes Class-->
        <h2>$($volumeTableCaption)</h2><br/>
        <table id=""Disks-Volumes-Table"">
        <tbody>
            <tr><!--Header Line-->
                <th><p style=""text-align:left;margin-left:-4px"">Name</p></th>
                <th><p>State</p></th>
                <th><p>Usage</p></th>
                <th><p>Owner</p></th>
                <th><p style=""line-height:1.2"">Bus <br/>Type</p></th>
                <th><p style=""line-height:1.2"">Partition <br/>Style</p></th>
                <th><p style=""line-height:1.2"">File <br/>System</p></th>
                <th><p style=""line-height:1.2"">Used <br/>Size</p></th>
                <th><p style=""line-height:1.2"">Free <br/>Size</p></th>
                <th><p style=""line-height:1.2"">Total <br/>Size</p></th>
            </tr>"

# Generate data lines
$outVolumeTable = $null
# Cluster
if ($Cluster) {

    # Check and get WMI Data
    $clusResourceDiskData = sGet-Wmi -ComputerName $clusterName -Namespace root\MSCluster -Class MSCluster_Resource -AI -Filter "Type='Physical Disk'" -Property Name,State,OwnerNode,IsClusterSharedVolume,StatusInformation
    if ($clusResourceDiskData[1] -eq 1)
    {
        $clusResourceDiskData = $clusResourceDiskData[0] | Sort-Object
        $clusResourceToDiskData = gwmi -ComputerName $clusterName -Namespace root\MSCluster -Class MSCluster_ResourceToDisk -Authentication PacketPrivacy -Impersonation Impersonate
        $clusDiskToDiskPartitionData = gwmi -ComputerName $clusterName -Namespace root\MSCluster -Class MSCluster_DiskToDiskPartition -Authentication PacketPrivacy -Impersonation Impersonate
        $clusDiskPartitionData = gwmi -ComputerName $clusterName -Namespace root\MSCluster -Class MSCluster_DiskPartition -Authentication PacketPrivacy -Impersonation Impersonate -Property FreeSpace,TotalSize,FileSystem,Path,MountPoints,VolumeLabel
        $msftDiskData = gwmi -ComputerName $clusterName -Namespace root\Microsoft\Windows\Storage -Class MSFT_Disk -Property AllocatedSize,BusType,Guid,IsClustered,Number,PartitionStyle,Signature,Size
        $msClusterData = gwmi -ComputerName $clusterName -Namespace root\MSCluster -Class MSCluster_Cluster -Authentication PacketPrivacy -Impersonation Impersonate -Property QuorumTypeValue,QuorumPath

        # If Quorum Disk, Determine Letter
        if ($msClusterData.QuorumTypeValue -eq 3)
        {
            if ($msClusterData.QuorumPath)
            {
                $quorumPathLetter = ($msClusterData.QuorumPath).Substring(0,2)
            }
            else
            {
                $quorumPathLetter = $null
            }
        }
        else
        {
            $quorumPathLetter = $null
        }

        # Each Cluster Disk Resource
        foreach($clusterDisk in $clusResourceDiskData)
        {
            $highL = $false
            $chargerVolumeTable = $null

            # According To The Cluster Disk State
            if ($clusterDisk.State -eq 2) # Online
            {
                # IsClusterSharedVolume True
                if ($clusterDisk.IsClusterSharedVolume -eq $true)
                {
                    $rtdGroupComponent = "MSCluster_Resource.Name=`"$($clusterDisk.Name)`""
                    $clusterDiskID = ($clusResourceToDiskData | where{$_.GroupComponent -eq $rtdGroupComponent}).PartComponent
                    $shortClusterDiskID = $clusterDiskID.TrimStart("MSCluster_Disk.Id=`"").TrimEnd("`"")
                    $busTypeName = sConvert-BusTypeName -BusTypeValue ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).bustype
                    $diskPartitionStyle = sConvert-DiskPartitionStyle -PartitionStyleValue ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).PartitionStyle
                    $clusterDiskSize = sConvert-Size -DiskVolumeSpace ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).Size -DiskVolumeSpaceUnit byte
                    $clusterDiskAllocatedSize = sConvert-Size -DiskVolumeSpace ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).AllocatedSize -DiskVolumeSpaceUnit byte
                    $clusterDiskUnAllocatedSize = sConvert-Size -DiskVolumeSpace ((($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).Size) - (($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).AllocatedSize)) -DiskVolumeSpaceUnit byte
                    
                    # If maintenance mode enabled
                    if ($clusterDisk.StatusInformation -eq 1)
                    {
                        $clusterDiskPartitionPaths = ((($clusDiskToDiskPartitionData | where{$_.GroupComponent -eq $clusterDiskID}).PartComponent) -replace "MSCluster_DiskPartition.Path=`"","").TrimEnd("`"")
                        $clusDiskVolumeData = Get-ClusterSharedVolume -Cluster $ClusterName -Name $clusterDisk.Name

                        foreach($clusterDiskPartitionPath in $clusterDiskPartitionPaths)
                        {
                            $outDiskName = $clusterDisk.Name
                            $outVolumePath = ($clusDiskVolumeData.SharedVolumeInfo | where{$_.Partition.Name -eq $clusterDiskPartitionPath}).FriendlyVolumeName
                            $outVolumeName = $outVolumePath.Split("\")[-1]
                            $outVolumeFS = (($clusDiskVolumeData.SharedVolumeInfo.Partition) | where{$_.Name -eq $clusterDiskPartitionPath}).FileSystem
                            $outDiskState = "Maintenance","#BDD7EE","#204F7A"
                            $outDiskOwner = $clusterDisk.OwnerNode
                            $outBusType = $busTypeName
                            $outDiskPartStyle = $diskPartitionStyle
                            $outVolumeTotalSize = sConvert-Size -DiskVolumeSpace (($clusDiskVolumeData.SharedVolumeInfo.Partition) | where{$_.Name -eq $clusterDiskPartitionPath}).Size -DiskVolumeSpaceUnit byte
                            $outVolumeFreeSpace = sConvert-Size -DiskVolumeSpace (($clusDiskVolumeData.SharedVolumeInfo.Partition) | where{$_.Name -eq $clusterDiskPartitionPath}).FreeSpace -DiskVolumeSpaceUnit byte
                            $outVolumeUsedSpace = sConvert-Size -DiskVolumeSpace (($clusDiskVolumeData.SharedVolumeInfo.Partition) | where{$_.Name -eq $clusterDiskPartitionPath}).UsedSpace -DiskVolumeSpaceUnit byte
                            $volumeFreePercent = [math]::Round((($clusDiskVolumeData.SharedVolumeInfo.Partition) | where{$_.Name -eq $clusterDiskPartitionPath}).PercentFree)
                            $outVolumeFreePercent = "&nbsp;~%" + $volumeFreePercent + " free&nbsp;"
                            $outVolumeUsage = "CSV"
                                
                            # Volume Free Space Colors
                            $volumeFreeSpaceColors = sConvert-VolumeSizeColors -FreePercent $volumeFreePercent
                             
                            $outVolumeTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""$($outVolumePath)"">$($outVolumeName) <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left""><abbr title=""PhysicalSize: $($clusterDiskSize) | Allocated: $($clusterDiskAllocatedSize) | Unallocated: ~$($clusterDiskUnAllocatedSize)"">$($outDiskName) <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>$outVolumeUsage</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>$outBusType</p></td>
                <td><p>$outDiskPartStyle</p></td>
                <td><p>$outVolumeFS</p></td>
                <td><p style=""line-height:1.2"">$($outVolumeUsedSpace[0])<br/><span style=""font-size:10px""> $($outVolumeUsedSpace[1])</span></p></td>
                <td bgcolor=""$($volumeFreeSpaceColors[0])""><p style=""line-height:1.2"">$($outVolumeFreeSpace[0])<br/><span style=""font-size:10px""> $($outVolumeFreeSpace[1])</span></p></td>
                <td><p style=""line-height:1.2"">$($outVolumeTotalSize[0])<span style=""font-size:10px""> $($outVolumeTotalSize[1])</span><br><span style=""font-size:10px;background-color:$($volumeFreeSpaceColors[1]);color:$($volumeFreeSpaceColors[2])"">$outVolumeFreePercent</span></p></td>
            </tr>"
                        }
                    }
                    else
                    {
                        $clusterDiskPartitionPaths = (($clusDiskToDiskPartitionData | where{$_.GroupComponent -eq $clusterDiskID}).PartComponent).TrimStart("MSCluster_DiskPartition.Path=`"\\\\?\\Volume").TrimEnd("\\`"")
  
                        foreach($clusterDiskPartitionPath in $clusterDiskPartitionPaths)
                        {
                            $highL = $false
                            $outDiskName = $clusterDisk.Name
                            $outVolumePath = ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).MountPoints
                            $outVolumeName = (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).MountPoints).Split("\")[-1]
                            $outVolumeLabel = ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).VolumeLabel
                            $outVolumeFS = ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FileSystem
                            $outDiskState = (sConvert-ClusterDiskState -StateValue $clusterDisk.State)
                                if ($outDiskState[0] -ne "Online")
                                {
                                    $highL = $true
                                }
                            $outDiskOwner = $clusterDisk.OwnerNode
                            $outBusType = $busTypeName
                            $outDiskPartStyle = $diskPartitionStyle
                            $outVolumeTotalSize = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize) -DiskVolumeSpaceUnit mb)
                            $outVolumeFreeSpace = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) -DiskVolumeSpaceUnit mb)
                            $outVolumeUsedSpace = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize - ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) -DiskVolumeSpaceUnit mb)
                            $volumeFreePercent = [math]::Round((((($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) / (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize))) * 100)
                            $outVolumeFreePercent = "&nbsp;~%" + $volumeFreePercent + " free&nbsp;"
                            $outVolumeUsage = "CSV"
                                
                            # Volume Free Space Colors
                            $volumeFreeSpaceColors = sConvert-VolumeSizeColors -FreePercent $volumeFreePercent
                            
                            if ($volumeFreePercent -le 10)
                            {
                                $highL = $true
                            }

                            # Data Line
                            $chargerVolumeTable ="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""$($outVolumePath)"">$($outVolumeName) <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left""><abbr title=""PhysicalSize: $($clusterDiskSize) | Allocated: $($clusterDiskAllocatedSize) | Unallocated: ~$($clusterDiskUnAllocatedSize)"">$($outDiskName) <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>$outVolumeUsage</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>$outBusType</p></td>
                <td><p>$outDiskPartStyle</p></td>
                <td><p>$outVolumeFS</p></td>
                <td><p style=""line-height:1.2"">$($outVolumeUsedSpace[0])<br/><span style=""font-size:10px""> $($outVolumeUsedSpace[1])</span></p></td>
                <td bgcolor=""$($volumeFreeSpaceColors[0])""><p style=""line-height:1.2"">$($outVolumeFreeSpace[0])<br/><span style=""font-size:10px""> $($outVolumeFreeSpace[1])</span></p></td>
                <td><p style=""line-height:1.2"">$($outVolumeTotalSize[0])<span style=""font-size:10px""> $($outVolumeTotalSize[1])</span><br><span style=""font-size:10px;background-color:$($volumeFreeSpaceColors[1]);color:$($volumeFreeSpaceColors[2])"">$outVolumeFreePercent</span></p></td>
            </tr>"
                            # Add to HTML Table
                            if ($HighlightsOnly -eq $false)
                            {
                                $outVolumeTable += $chargerVolumeTable
                            }
                            elseif (($HighlightsOnly -eq $true) -and ($highL -eq $true))
                            {
                                $outVolumeTable += $chargerVolumeTable
                            }
                            else
                            {
                                # Blank
                            }
                        }
                    } 
                }
                else # IsClusterSharedVolume False
                {
                    $rtdGroupComponent = "MSCluster_Resource.Name=`"$($clusterDisk.Name)`""
                    $clusterDiskID = ($clusResourceToDiskData | where{$_.GroupComponent -eq $rtdGroupComponent}).PartComponent
                    $shortClusterDiskID = $clusterDiskID.TrimStart("MSCluster_Disk.Id=`"").TrimEnd("`"")

                    $clusterDiskPartitionPaths = ((($clusDiskToDiskPartitionData | where{$_.GroupComponent -match $clusterDiskID}).PartComponent) -replace "MSCluster_DiskPartition.Path=`"","").TrimEnd("`"")

                    $busTypeName = sConvert-BusTypeName -BusTypeValue ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).bustype
                    $diskPartitionStyle = sConvert-DiskPartitionStyle -PartitionStyleValue ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).PartitionStyle
                    $clusterDiskSize = sConvert-Size -DiskVolumeSpace ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).Size -DiskVolumeSpaceUnit byte
                    $clusterDiskAllocatedSize = sConvert-Size -DiskVolumeSpace ($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).AllocatedSize -DiskVolumeSpaceUnit byte
                    $clusterDiskUnAllocatedSize = sConvert-Size -DiskVolumeSpace ((($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).Size) - (($msftDiskData | where{($_.Guid -eq $shortClusterDiskID) -or ($_.Signature -eq $shortClusterDiskID)}).AllocatedSize)) -DiskVolumeSpaceUnit byte

                    foreach ($clusterDiskPartitionPath in $clusterDiskPartitionPaths)
                    {
                        $highL = $false

                        # Missing Volume (drive) Letters
                        if ($clusterDiskPartitionPath -match "Volume")
                        {
                            $clusterDiskPartitionPath = $clusterDiskPartitionPath.trimStart("MSCluster_DiskPartition.Path=`"\\\\?\\Volume").TrimEnd("`"")
                            $outVolumeName = "<span style=""background-color:$($stateBgColors[4]);color:$($stateWordColors[4])"">&nbsp;No Letter&nbsp;</span>"
                            $highL = $true
                        }
                        else
                        {
                            $clusterDiskPartitionPath = ($clusterDiskPartitionPath -replace "MSCluster_DiskPartition.Path=`"","").TrimEnd("`"")
                            $outVolumeName = $clusterDiskPartitionPath
                        }
                           
                        $outDiskName = $clusterDisk.Name
                        $outVolumeLabel = ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).VolumeLabel
                        $outVolumeFS = ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FileSystem

                        if ($clusterDisk.StatusInformation -eq 1)
                        {
                            $outDiskState = "Maintenance","#BDD7EE","#204F7A"
                        }
                        else
                        {
                            $outDiskState = (sConvert-ClusterDiskState -StateValue $clusterDisk.State)
                        }

                        if ($outDiskState[0] -ne "Online")
                        {
                            $highL = $true
                        }

                        $outDiskOwner = $clusterDisk.OwnerNode
                        $outBusType = $busTypeName
                        $outDiskPartStyle = $diskPartitionStyle
                        $outVolumeTotalSize = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize) -DiskVolumeSpaceUnit mb)
                        $outVolumeFreeSpace = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) -DiskVolumeSpaceUnit mb)
                        $outVolumeUsedSpace = (sConvert-Size -DiskVolumeSpace (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize - ($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) -DiskVolumeSpaceUnit mb)
                        $volumeFreePercent = [math]::Round((((($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).FreeSpace) / (($clusDiskPartitionData | where{$_.Path -match $clusterDiskPartitionPath}).TotalSize))) * 100)
                        $outVolumeFreePercent = "&nbsp;~%" + $volumeFreePercent + " free&nbsp;"
                           
                        # Volume Usage Type
                        if ($outVolumeName -eq $quorumPathLetter)
                        {
                            $outVolumeUsage = "Quorum"
                        }
                        else
                        {
                            $outVolumeUsage = "Volume"
                        }
                            
                        # Volume Free Space Colors
                        $volumeFreeSpaceColors = sConvert-VolumeSizeColors -FreePercent $volumeFreePercent

                        if ($volumeFreePercent -le 10)
                        {
                            $highL = $true
                        }

                        $chargerVolumeTable = "
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""$($outVolumeLabel)"">$($outVolumeName) <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left""><abbr title=""PhysicalSize: $($clusterDiskSize) | Allocated: $($clusterDiskAllocatedSize) | Unallocated: ~$($clusterDiskUnAllocatedSize)"">$($outDiskName) <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>$outVolumeUsage</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>$outBusType</p></td>
                <td><p>$outDiskPartStyle</p></td>
                <td><p>$outVolumeFS</p></td>
                <td><p style=""line-height:1.2"">$($outVolumeUsedSpace[0])<br/><span style=""font-size:10px""> $($outVolumeUsedSpace[1])</span></p></td>
                <td bgcolor=""$($volumeFreeSpaceColors[0])""><p style=""line-height:1.2"">$($outVolumeFreeSpace[0])<br/><span style=""font-size:10px""> $($outVolumeFreeSpace[1])</span></p></td>
                <td><p style=""line-height:1.2"">$($outVolumeTotalSize[0])<span style=""font-size:10px""> $($outVolumeTotalSize[1])</span><br><span style=""font-size:10px;background-color:$($volumeFreeSpaceColors[1]);color:$($volumeFreeSpaceColors[2])"">$outVolumeFreePercent</span></p></td>
            </tr>"
                        # Add to HTML Table
                        if ($HighlightsOnly -eq $false)
                        {
                            $outVolumeTable += $chargerVolumeTable
                        }
                        elseif (($HighlightsOnly -eq $true) -and ($highL -eq $true))
                        {
                            $outVolumeTable += $chargerVolumeTable
                        }
                        else
                        {
                            # Blank
                        }
                    }
                }
            }
            elseif (($clusterDisk.State -eq 3) -or ($clusterDisk.State -eq 127)) # Offline
            {
                if ($HighlightsOnly -eq $false)
                {
                    $outDiskName = $clusterDisk.Name
                    $outDiskState = (sConvert-ClusterDiskState -StateValue $clusterDisk.State)
                    $outDiskOwner = $clusterDisk.OwnerNode

                    $outVolumeTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""Disk is Offline"">$outDiskName <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Unknown Volume</span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>-</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
            </tr>"
                }
            }
            elseif ($clusterDisk.State -eq 4) # Failed
            {
                $outDiskName = $clusterDisk.Name
                $outDiskState = (sConvert-ClusterDiskState -StateValue $clusterDisk.State)
                $outDiskOwner = $clusterDisk.OwnerNode

                $outVolumeTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""Disk is Failed"">$outDiskName <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Unknown Volume</span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>-</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
            </tr>"
            }
            else # Others
            {
                $outDiskName = $clusterDisk.Name
                $outDiskState = (sConvert-ClusterDiskState -StateValue $clusterDisk.State)
                $outDiskOwner = $clusterDisk.OwnerNode

                $outVolumeTable +="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""Disk is Not Operational"">$outDiskName <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Unknown Volume</span></p></td>
                <td bgcolor=""$($outDiskState[1])""><p style=""color:$($outDiskState[2])"">$($outDiskState[0])</p></td>
                <td><p>-</p></td>
                <td><p>$outDiskOwner</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
            </tr>"
            }
        }
    }
    elseif ($clusResourceDiskData[1] -eq 2)
    {
        $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center;color:#BDBDBD"">Hyper-V Cluster does not have any Disk/Volume</p></td>
            </tr>"
    }
    else
    {
        sPrint -Type 0 -Message "$ClusterName`: Gathering Disk/Volume information failed. $($clusResourceDiskData[0])" -WriteToLogFile $True
        Start-Sleep -Seconds 3
        $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center;color:#BDBDBD"">$($clusResourceDiskData[0])</p></td>
            </tr>"
    }
}

# Standalone
if ($VMHost)
{
    $Computers = $VMHosts
    
    foreach ($ComputerName in $Computers)
    {
        $LogicalDisks = sGet-Wmi -ComputerName $ComputerName -Namespace root\CIMv2 -Class Win32_LogicalDisk -AI -Filter "DriveType='3'"
        if ($LogicalDisks[1] -eq 1)
        {
            $LogicalDisks = $LogicalDisks[0]
            $SystemDrive = ((gwmi -ComputerName $ComputerName -Class Win32_OperatingSystem).SystemDirectory).Substring(0,2)

            foreach ($LogicalDisk in $LogicalDisks)
            {
                $highL = $false
                $chargerVolumeTable = $null

                $logicalToDiskPartition = ((gwmi -ComputerName $ComputerName -Namespace root\CIMv2 -Class Win32_LogicalDiskToPartition | where{$_.Dependent -match $LogicalDisk.Name}).Antecedent).ToString()
                $diskPartition = gwmi -ComputerName $ComputerName -Namespace root\CIMv2 -Class Win32_DiskPartition | where{$logicalToDiskPartition -match $_.DeviceID} #Bootable(true/false)
                $physicalDiskName = (((gwmi -ComputerName $ComputerName -Namespace root\CIMv2 -Class Win32_DiskDriveToDiskPartition | where{$_.Dependent -match $diskPartition.DeviceID}).Antecedent).Split("`"")).TrimStart(".\")[1]
                $diskDrive = gwmi -ComputerName $ComputerName -Namespace root\CIMv2 -Class Win32_DiskDrive | where{$_.DeviceID -match $physicalDiskName}
                $msftDisk = gwmi -ComputerName $ComputerName -Namespace root\Microsoft\Windows\Storage -Class MSFT_Disk | where{$_.SerialNumber -match $diskDrive.SerialNumber}
                $outLogicalDiskName = $LogicalDisk.Name
                $outLogicalDiskVolumeName = $LogicalDisk.VolumeName
                $outPhysicalDiskName = $physicalDiskName.Replace("PHYSICALDRIVE","Disk")
                $outMsftDiskSize = sConvert-Size -DiskVolumeSpace $msftDisk.Size -DiskVolumeSpaceUnit byte
                $outMsftDiskAllocatedSize = sConvert-Size -DiskVolumeSpace $msftDisk.AllocatedSize -DiskVolumeSpaceUnit byte
                $outmsftDiskUnallocatedSize = sConvert-Size -DiskVolumeSpace ($msftDisk.Size - $msftDisk.AllocatedSize) -DiskVolumeSpaceUnit byte
                $msftDiskState = "Online"

                if ($LogicalDisk.Name -eq $SystemDrive)
                {
                    $LogicalDiskUsage = "System"
                }
                else
                {
                    $LogicalDiskUsage = "Data"
                }

                $msftDiskOwner = ($ComputerName).ToUpper()
                $outMsftDiskBusType = sConvert-BusTypeName -BusTypeValue $msftDisk.BusType
                $outMsftDiskPartitionStyle = sConvert-DiskPartitionStyle -PartitionStyleValue $msftDisk.PartitionStyle
                $outLogicalDiskFS = $LogicalDisk.FileSystem
                $outLogicalDiskUsedSpace = sConvert-Size -DiskVolumeSpace ($LogicalDisk.Size - $LogicalDisk.FreeSpace) -DiskVolumeSpaceUnit byte
                $outLogicalDiskFreeSpace = sConvert-Size -DiskVolumeSpace $LogicalDisk.FreeSpace -DiskVolumeSpaceUnit byte
                $outLogicalDiskSize = sConvert-Size -DiskVolumeSpace $LogicalDisk.Size -DiskVolumeSpaceUnit byte
                $LogicalDiskFreePercent = [math]::Round((($LogicalDisk.FreeSpace) / ($LogicalDisk.Size)) * 100)
                $outLogicalDiskFreePercent = "&nbsp;~%" + $LogicalDiskFreePercent + " free&nbsp;"

                # Volume Free Space Colors
                $LogicalDiskFreeSpaceColors = sConvert-VolumeSizeColors -FreePercent $LogicalDiskFreePercent
                if ($LogicalDiskFreePercent -le 10)
                {
                    $highL = $true
                }

                # Data Line
                $chargerVolumeTable ="
            <tr><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""$($outLogicalDiskVolumeName)"">$($outLogicalDiskName) <span style=""font-size:10px;color:orange"">*</span></abbr><br/><span style=""font-size:10px;color:#BDBDBD;text-align:left""><abbr title=""PhysicalSize: $($outMsftDiskSize) | Allocated: $($outMsftDiskAllocatedSize) | Unallocated: ~$($outmsftDiskUnallocatedSize)"">$($outPhysicalDiskName) <span style=""font-size:10px;color:orange"">*</span></abbr></span></p></td>
                <td bgcolor=""$($stateBgColors[1])""><p style=""color:$($stateWordColors[1])"">$($msftDiskState)</p></td>
                <td><p>$LogicalDiskUsage</p></td>
                <td><p>$msftDiskOwner</p></td>
                <td><p>$outMsftDiskBusType</p></td>
                <td><p>$outMsftDiskPartitionStyle</p></td>
                <td><p>$outLogicalDiskFS</p></td>
                <td><p style=""line-height:1.2"">$($outLogicalDiskUsedSpace[0])<br/><span style=""font-size:10px""> $($outLogicalDiskUsedSpace[1])</span></p></td>
                <td bgcolor=""$($LogicalDiskFreeSpaceColors[0])""><p style=""line-height:1.2"">$($outLogicalDiskFreeSpace[0])<br/><span style=""font-size:10px""> $($outLogicalDiskFreeSpace[1])</span></p></td>
                <td><p style=""line-height:1.2"">$($outLogicalDiskSize[0])<span style=""font-size:10px""> $($outLogicalDiskSize[1])</span><br><span style=""font-size:10px;background-color:$($LogicalDiskFreeSpaceColors[1]);color:$($LogicalDiskFreeSpaceColors[2])"">$outLogicalDiskFreePercent</span></p></td>
            </tr>"
                
                # Add to HTML Table
                if ($HighlightsOnly -eq $false)
                {
                    $outVolumeTable += $chargerVolumeTable
                }
                elseif (($HighlightsOnly -eq $true) -and ($highL -eq $true))
                {
                    $outVolumeTable += $chargerVolumeTable
                }
                else
                {
                    # Blank
                }
            }   
        }
        elseif ($LogicalDisks[1] -eq 2)
        {
            $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center;color:#BDBDBD"">$($ComputerName.ToUpper()) does not have any Disk/Volume</p></td>
            </tr>"
            Continue
        }
        else
        {
            # Error
            sPrint -Type 0 -Message "$($ComputerName.ToUpper()): Gathering Disk/Volume information failed. $($LogicalDisks[0])" -WriteToLogFile $True
            Start-Sleep -Seconds 3
            $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center;color:#BDBDBD"">$($LogicalDisks[0])</p></td>
            </tr>"
            Continue
        }
    }
}

if ($outVolumeTable -eq $null)
{
    if ($Cluster)
    {
        $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center""><span style=""padding-top:1px;padding-bottom:1px;background-color:#ACFA58;color:#298A08"">&nbsp;&nbsp;All Clustered Disks/Volumes are healthy&nbsp;&nbsp;</span></p></td>
            </tr>"
    }
    else
    {
        $outVolumeTable +="
            <tr><!--Data Line-->
                <td colspan=""10""><p style=""text-align:center""><span style=""padding-top:1px;padding-bottom:1px;background-color:#ACFA58;color:#298A08"">&nbsp;&nbsp;All Local Disks/Volumes are healthy&nbsp;&nbsp;</span></p></td>
            </tr>"
    }
}

# HTML Disk Table - End
$outVolumeTableEnd ="
        </tbody>
        </table>
    </div><!--End Disks-Volumes Class-->"

#endregion

#region Gathering VM Information
#-------------------------------

# Print MSG
sPrint -Type 1 "Gathering VM information..." -WriteToLogFile $True

$outVMTableStart = "
    <div class=""VMs""><!--Start VM Class-->
        <h2>Virtual Machines</h2><br>
        <table>
        <tbody>
            <tr><!--Header Line-->
                <th><p style=""text-align:left;margin-left:-4px"">Name</p></th>
                <th><p>State</p></th>
                <th><p>Uptime</p></th>
                <th><p>Host</p></th>
                <th><p>vCPU</p></th>
                <th colspan=""4""><p>vRAM <br/><span style=""font-size:10px;color:#BDBDBD"">Startup | Min | Max | Assigned</span></p></th>
                <th><p style=""line-height:1.2"">Integration <br/>Services</p></th>
                <th><p style=""line-height:1.2"">Check <br/>Point</p></th>
                <th><p style=""line-height:1.2"">Replica <br/>Health</p></th>
                <th><p>Disk</p></th>
            </tr>"

# Generate Data Lines
$outVmTable = $null
$cntVM = 0
$vmNoInTable = 0

ForEach ($VMHost in $VMHosts) {
    
    $getVMerr = $null
    $VMs = Get-VM -ComputerName $VMHost -ErrorVariable getVMerr -ErrorAction SilentlyContinue

    # Detect offline Virtual Machine Configuration resource
    if ($Cluster)
    {
        $offlineVmConfigData = Get-ClusterResource -Cluster $ClusterName | where{($_.ResourceType -eq "Virtual Machine Configuration") -and ($_.State -eq "Offline") -and ($_.OwnerNode -eq "$VMHost")}
    }

    # Success Get-VM
    if ($VMs)
    {
        $cntVM = $cntVM + 1
        
        foreach ($VM in $VMs)
        {
            $highL = $false
            $chargerVmTable = $null
            $outVmReplReplicaServer = $null
            $outVmReplFrequency = $null

            # Table TR Color
            if([bool]!($vmNoInTable%2))
            {
               #Even or Zero
               $vmTableTrBgColor = ""
            }
            else
            {
               #Odd
               $vmTableTrBgColor = "#F9F9F9"
            }

            # Name and Config Path
            $outVmName = $VM.VMName
            $outVmPath = $VM.ConfigurationLocation

            # Generation and Version
            if (!$VM.Generation -and !$VM.Version)
            {
                $outVmGenVer = "<span style=""font-size:10px;color:#BDBDBD;text-align:left"">"
            }
            else
            {
                $outVmGenVer = "<br/><span style=""font-size:10px;color:#BDBDBD;text-align:left"">Gen$($VM.Generation) (v$($VM.Version))"
            }

            # VM State
            $outVmState = $VM.State

            # IsClustered or Not
            if (($VM.State -ne "Running") -and ($VM.IsClustered -eq $True))
            {
                $getClusVMerr = $null
                $outVmIsClustered = "Yes"
                $outVmState = (Get-ClusterResource -Cluster $ClusterName -VMId $VM.VMId -ErrorAction SilentlyContinue -ErrorVariable getClusVMerr).State

                if ($getClusVMerr)
                {
                    $outVmState = "Unknown"
                }
                elseif ($outVmState -eq "Online")
                {
                    $outVmState = "Running"
                }
                elseif ($outVmState -eq "Offline")
                {
                    $outVmState = "Off"
                }
                else
                {
                    $outVmState = $outVmState
                }
            }
            else
            {
                $outVmIsClustered = "No"
            }          

            # VM State Color
            if ($outVmState -eq "Running")
            {
                $vmStateBgColor = $stateBgColors[1]
                $vmStateWordColor = $stateWordColors[1]
            }
            Elseif ($outVmState -eq "Off")
            {
                $vmStateBgColor = $stateBgColors[2]
                $vmStateWordColor = $stateWordColors[2]
            }
            Elseif (($outVmState -match "Critical") -or ($outVmState -match "Failed"))
            {
                $vmStateBgColor = $stateBgColors[3]
                $vmStateWordColor = $stateWordColors[3]
                $highL = $true
            }
            Elseif (($outVmState -eq "Paused") -or ($outVmState -eq "Saved"))
            {
                $vmStateBgColor = $stateBgColors[4]
                $vmStateWordColor = $stateWordColors[4]
                $highL = $true
            }
            else
            {
                $vmStateBgColor = $stateBgColors[5]
                $vmStateWordColor = $stateWordColors[5]
            }
        
            # Uptime
            if ($VM.Uptime -eq "00:00:00")
            {
                $outVmUptimeDays = $null
                $outVmUptime = "Stopped"
            }
            else
            {
                $outVmUptimeDays = (($VM.Uptime).Days).ToString()
                    if ($outVmUptimeDays -eq "0")
                    {
                        $outVmUptimeDays = $null
                    }
                    else
                    {
                        $outVmUptimeDays = $outVmUptimeDays + " <span style=""font-size:10px;color:#BDBDBD"">Days</span> <br/>"
                    }
                $outVmUptime = (($VM.Uptime).Hours).ToString() + ":" + (($VM.Uptime).Minutes).ToString() + ":" + (($VM.Uptime).Seconds).ToString()
            }

            # Owner Host
            $outVmHost = ($VM.ComputerName).ToUpper()

            # vCPU
            $outVmCPU = $VM.ProcessorCount

            # vRAM
            $outVmDmEnabled = $VM.DynamicMemoryEnabled #true, false
            
            # Startup Memory
            $outVmMemStartup = sConvert-Size -DiskVolumeSpace $VM.MemoryStartup -DiskVolumeSpaceUnit byte
        
            # Assigned Memory
            if ($VM.MemoryAssigned -eq 0)
            {
                $outVmMemAssigned = "-"
            }
            else
            {
                $outVmMemAssigned = sConvert-Size -DiskVolumeSpace $VM.MemoryAssigned -DiskVolumeSpaceUnit byte
            }

            # Max, Min if DM enabled
            if ($outVmDmEnabled -eq $true)
            {
                $outVmMemMax = sConvert-Size -DiskVolumeSpace $VM.MemoryMaximum -DiskVolumeSpaceUnit byte
                $outVmMemMin = sConvert-Size -DiskVolumeSpace $VM.MemoryMinimum -DiskVolumeSpaceUnit byte 
            }
            else
            {
                $outVmMemMax = "-"
                $outVmMemMin = "-"
            }
        
            # IS State, Version and Color
            if ($VM.IntegrationServicesState -eq "Up to date")
            {
                $outVmIs = "UpToDate"
                $outVmIsVer = $VM.IntegrationServicesVersion
                $vmIsStateBgColor = ""
                $vmIsStateWordColor = ""
            }
            elseif ($VM.IntegrationServicesState -eq "Update required")
            {
                $outVmIs = "UpdateRequired"
                $outVmIsVer = $VM.IntegrationServicesVersion
                $vmIsStateBgColor = $stateBgColors[4]
                $vmIsStateWordColor = $stateWordColors[4]
                $highL = $true
            }
            else
            {
                if ($vm.State -eq "Running")
                {
                    if ($VM.IntegrationServicesVersion -eq "6.2.9200.16433")
                    {
                        $outVmIs = "UpToDate"
                        $outVmIsVer = $VM.IntegrationServicesVersion
                        $vmIsStateBgColor = ""
                        $vmIsStateWordColor = ""
                    }
                    elseif ($VM.IntegrationServicesVersion -eq $null)
                    {
                        $outVmIs = "NotDetected"
                        $outVmIsVer = "NotDetected"
                        $vmIsStateBgColor = ""
                        $vmIsStateWordColor = ""
                    }
                    else
                    {
                        $outVmIs = "MayBeRequired"
                        $outVmIsVer = $VM.IntegrationServicesVersion
                        $vmIsStateBgColor = ""
                        $vmIsStateWordColor = ""
                    }
                }
                else
                {
                    $outVmIs = "NotDetected"
                    $outVmIsVer = "NotDetected"
                    $vmIsStateBgColor = ""
                    $vmIsStateWordColor = ""
                }
            }
        
            # Checkpoint State and Color
            if ($VM.ParentSnapshotId)
            {
                $outVmChekpoint = "Yes"
                $vmCheckpointBgColor = $stateBgColors[4]
                $vmCheckpointWordColor = $stateWordColors[4]
                $outVmChekpointCount = ((Get-VMSnapshot -ComputerName $VM.ComputerName -VMName $VM.Name).Count).ToString() + " Checkpoint(s)"
                $highL = $true
            }
            else
            {
                $outVmChekpoint = "No"
                $vmCheckpointBgColor = ""
                $vmCheckpointWordColor = ""
                $outVmChekpointCount = $null
            }

            # Replication
            if ($VM.ReplicationState -ne "Disabled")
            {
                $outVmReplHealth = $VM.ReplicationHealth #NotApplicable, Normal, Warning, Critical
                $getVmReplication = Get-VMReplication -ComputerName $VM.ComputerName -VMName $VM.Name
                $outVMReplState = "ReplState: $($VM.ReplicationState) &#10;"
                $outVmReplReplicaServer = "ReplServer: $($getVmReplication.ReplicaServerName) &#10;"
            
                # Repl Frequency
                if ($getVmReplication.ReplicationFrequencySec -gt 30)
                {
                    $outVmReplFrequency = "ReplFrequency: " + (($getVmReplication.ReplicationFrequencySec)/60) + " Min."
                }
                else
                {
                    $outVmReplFrequency = "ReplFrequency: " + ($getVmReplication.ReplicationFrequencySec) + " Sec."
                }

                # Repl Health Colors
                if ($outVmReplHealth -eq "Normal")
                {
                    $vmReplHealthBgColor = $stateBgColors[1]
                    $vmReplHealthWordColor = $stateWordColors[1]
                }
                elseif ($outVmReplHealth -eq "Warning")
                {
                    $vmReplHealthBgColor = $stateBgColors[4]
                    $vmReplHealthWordColor = $stateWordColors[4]
                    $highL = $true
                }
                elseif ($outVmReplHealth -eq "Critical")
                {
                    $vmReplHealthBgColor = $stateBgColors[3]
                    $vmReplHealthWordColor = $stateWordColors[3]
                    $highL = $true
                }
                else
                {
                    $vmReplHealthBgColor = $stateBgColors[5]
                    $vmReplHealthWordColor = $stateWordColors[5]
                    $highL = $true
                }
            }
            else
            {
                $outVmReplHealth = "N/A"
                $vmReplHealthBgColor = ""
                $vmReplHealthWordColor = ""
            }

            # Get Disks
            $vmDiskOutput = $null
            $rowSpanCount = 0
            $getVhdErr = $null
            $vmDisks = Get-VHD -ComputerName $VMHost -VMId $vm.VMId -ErrorAction SilentlyContinue -ErrorVariable getVhdErr
            
            if ($getVhdErr)
            {
                if ($rowSpanCount -eq 0)
                {
			        $vmDiskOutput +="
                <td><p style=""text-align:left""><span style=""background-color:$($stateBgColors[3]);color:$($stateWordColors[3])"">&nbsp;$($getVhdErr.count) VHD file(s) missing&nbsp;</span> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; CurrentFileSize:N/A (MaxDiskSize:N/A) <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; VhdType:N/A | ControllerType:N/A | Fragmentation:N/A</span></p></td>
            </tr>"
                    $highL = $true
                    $rowSpanCount = $rowSpanCount + 1
                }
                else
                {
                    $vmDiskOutput +="
            <tr style=""background:$($vmTableTrBgColor)"">
                <td Style=""border-top:2px dotted #ccc""><p style=""text-align:left""><span style=""background-color:$($stateBgColors[3]);color:$($stateWordColors[3])"">&nbsp;$($getVhdErr.count) VHD file(s) missing&nbsp;</span> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; CurrentFileSize:N/A (MaxDiskSize:N/A) <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; VhdType:N/A | ControllerType:N/A | Fragmentation:N/A</span></p></td>
            </tr>"
                    $highL = $true
                    $rowSpanCount = $rowSpanCount + 1
                }
            }

            $vmPTDisks = Get-VMHardDiskDrive -ComputerName $VMHost -VMname $vm.name | where{$_.Path -like "Disk*"}

            # Pass-trough
            $vmPTDiskNo = 1
            if ($vmPTDisks)
            {
                foreach ($vmPTDisk in $vmPTDisks)
                {
                    if ($rowSpanCount -eq 0)
                    {
			            $vmDiskOutput +="
                <td><p style=""text-align:left""><abbr title=""$($vmPTDisk.Path)"">Pass-through disk $vmPTDiskNo <span style=""font-size:10px;color:orange"">*</span></abbr> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; Path:$($vmPTDisk.Path)</span> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; ControllerType:$($vmPTDisk.ControllerType)</span></p></td>
            </tr>"
                        $rowSpanCount = $rowSpanCount + 1
                        $vmPTDiskNo = $vmPTDiskNo + 1
                    }
                    else
                    {
                        $vmDiskOutput +="
            <tr style=""background:$($vmTableTrBgColor)"">
                <td Style=""border-top:2px dotted #ccc""><p style=""text-align:left""><abbr title=""$($vmPTDisk.Path)"">Pass-through disk $vmPTDiskNo <span style=""font-size:10px;color:orange"">*</span></abbr> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; Path:$($vmPTDisk.Path)</span> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; ControllerType:$($vmPTDisk.ControllerType)</span></p></td>
            </tr>"
                        $rowSpanCount = $rowSpanCount + 1
                        $vmPTDiskNo = $vmPTDiskNo + 1
                    }               
                }
            }

            # VHD
            if ($vmDisks -eq $null){
                 $vmDiskOutput = "
                <td rowspan=""0""><p style=""text-align:left""><span style=""background-color:$($stateBgColors[4]);color:$($stateWordColors[4])"">&nbsp;Does not have a virtual disk&nbsp;</span></p></td>"
                $highL = $true
            }
            else
            {    
                foreach($vmDisk in $vmDisks)
                {
                    [array]$vmDiskData = $null

                    # Name, Path, Type, Size and File Size
                    $vmDiskName = $vmDisk.Path.Split('\')[-1]
                    $vmDiskPath = $vmDisk.Path
                    $vmDiskType = $vmDisk.VhdType
                    $vmDiskMaxSize = sConvert-Size -DiskVolumeSpace $vmDisk.Size -DiskVolumeSpaceUnit byte
                    $vmDiskFileSize = sConvert-Size -DiskVolumeSpace $vmDisk.FileSize -DiskVolumeSpaceUnit byte

                    # Get Controller Type
                    $vmDiskControllerType = (Get-VMHardDiskDrive -ComputerName $VMHost -VMName $vm.VMName | where{$_.Path -eq $vmDiskPath}).ControllerType

                    # VHD Fragmentation and Color
                    if ($vmDisk.FragmentationPercentage -eq $null)
                    {
                       $vmDiskFragmentation = "N/A"
                       $vmDiskFragmentationBgColor = ""
                       $vmDiskFragmentationTextColor = ""
                    }
                    else
                    {
                       $vmDiskFragmentation = "%$($vmDisk.FragmentationPercentage)"
                
                       if (($vmDisk.FragmentationPercentage -ge "30") -and ($vmDisk.FragmentationPercentage -lt "50")) 
                       {
                           $vmDiskFragmentationBgColor = $stateBgColors[4]
                           $vmDiskFragmentationTextColor = $stateWordColors[4]
                           $highL = $true
                       }
                       elseif ($vmDisk.FragmentationPercentage -ge "50") 
                       {
                           $vmDiskFragmentationBgColor = $stateBgColors[3]
                           $vmDiskFragmentationTextColor = $stateWordColors[3]
                           $highL = $true
                       }
                       else
                       {
                           $vmDiskFragmentationBgColor = ""
                           $vmDiskFragmentationTextColor = ""
                       }
                    }

                    # If differencing exist
                    if ($vmDisk.ParentPath)
                    {
                        $vmDiskData += "<p style=""margin-top:5px;text-align:left;text-indent:1nd3ntPlaceHolderpx""><abbr title=""$($vmDiskPath)"">$($vmDiskName)<span style=""font-size:10px;color:orange""> *</span></abbr> <br/><span style=""display:inline-block;text-indent:1nd3ntPlaceHolderpx;font-size:10px;color:#BDBDBD"">&#10148; CurrentFileSize:$($vmDiskFileSize[0])$($vmDiskFileSize[1]) (MaxDiskSize:$($vmDiskMaxSize[0])$($vmDiskMaxSize[1])) <br/><span style=""display:inline-block;text-indent:1nd3ntPlaceHolderpx;font-size:10px;color:#BDBDBD"">&#10148; VhdType:$($vmDiskType) | ControllerType:$($vmDiskControllerType) | Fragmentation:<span style=""color:$($vmDiskFragmentationTextColor);background-color:$($vmDiskFragmentationBgColor)"">$($vmDiskFragmentation)</span></span></p>"
                        $parentPath = $vmDisk.ParentPath

                        # Differencing disk loop
                        Do
                        {
                            $vmDiskName = $null
                            $vmDiskPath = $null
                            $vmDiskType = $null
                            $vmDiskMaxSize = $null
                            $vmDiskFileSize = $null
                            $vmDiffDisk = Get-VHD -ComputerName $VMHost -Path $parentPath
                            $vmDiskName = $vmDiffDisk.Path.Split('\')[-1]
                            $vmDiskPath = $vmDiffDisk.Path
                            $vmDiskType = $vmDiffDisk.VhdType
                            $vmDiskMaxSize = sConvert-Size -DiskVolumeSpace $vmDiffDisk.Size -DiskVolumeSpaceUnit byte
                            $vmDiskFileSize = sConvert-Size -DiskVolumeSpace $vmDiffDisk.FileSize -DiskVolumeSpaceUnit byte

                            # Disk Fragmentation and Color
                            if ($vmDiffDisk.FragmentationPercentage)
                            {
                                $vmDiskFragmentation = "%$($vmDiffDisk.FragmentationPercentage)"
                
                                if (($vmDiffDisk.FragmentationPercentage -ge "30") -and ($vmDiffDisk.FragmentationPercentage -lt "50")) 
                                {
                                    $vmDiskFragmentationBgColor = $stateBgColors[4]
                                    $vmDiskFragmentationTextColor = $stateWordColors[4]
                                    $highL = $true
                                }
                                elseif ($vmDiffDisk.FragmentationPercentage -ge "50") 
                                {
                                    $vmDiskFragmentationBgColor = $stateBgColors[3]
                                    $vmDiskFragmentationTextColor = $stateWordColors[3]
                                    $highL = $true
                                }
                                else
                                {
                                    $vmDiskFragmentationBgColor = ""
                                    $vmDiskFragmentationTextColor = ""
                                }
                            }

                            $vmDiskData += "<p style=""margin-top:5px;text-align:left;text-indent:1nd3ntPlaceHolderpx""><abbr title=""$($vmDiskPath)"">$($vmDiskName)<span style=""font-size:10px;color:orange""> *</span></abbr> <br/><span style=""display:inline-block;text-indent:1nd3ntPlaceHolderpx;font-size:10px;color:#BDBDBD"">&#10148; CurrentFileSize:$($vmDiskFileSize[0])$($vmDiskFileSize[1]) (MaxDiskSize:$($vmDiskMaxSize[0])$($vmDiskMaxSize[1]))</span> <br/><span style=""display:inline-block;text-indent:1nd3ntPlaceHolderpx;font-size:10px;color:#BDBDBD"">&#10148; VhdType:$($vmDiskType) | ControllerType:$($vmDiskControllerType) | Fragmentation:<span style=""color:$($vmDiskFragmentationTextColor);background-color:$($vmDiskFragmentationBgColor)"">$($vmDiskFragmentation)</span></span></p>"
                            $parentPath = $vmDiffDisk.ParentPath
                        }
                        Until ($parentPath -eq $null) 
                    }
                    else
                    {
                        $vmDiskData = "<p style=""text-align:left""><abbr title=""$($vmDiskPath)"">$($vmDiskName)<span style=""font-size:10px;color:orange""> *</span></abbr> <br/><span style=""font-size:10px;color:#BDBDBD"">&#10148; CurrentFileSize:$($vmDiskFileSize[0])$($vmDiskFileSize[1]) (MaxDiskSize:$($vmDiskMaxSize[0])$($vmDiskMaxSize[1])) <br/>&#10148; VhdType:$($vmDiskType) | ControllerType:$($vmDiskControllerType) | Fragmentation:<span style=""color:$($vmDiskFragmentationTextColor);background-color:$($vmDiskFragmentationBgColor)"">$($vmDiskFragmentation)</span></span></p>"
                    }

                    # Remove top-margin of last item
                    $vmDiskData[-1] = $vmDiskData[-1].Replace("margin-top:5px;","")

                    # Add Indents
                    $itemC = 0
                    $indentV = ($vmDiskData.count - 1) * 14

                    Do
                    {
                        $vmDiskData[$itemC] = $vmDiskData[$itemC].Replace("1nd3ntPlaceHolder","$indentV")
                        $indentV = $indentV - 14
                        $itemC = $itemC + 1
                    }
                    Until ($itemC -eq $vmDiskData.Count)


                    # Convert String
                    [array]::Reverse($vmDiskData) 
                    $vmDiskData = ($vmDiskData -join "").ToString()

                    # Write
                    if ($rowSpanCount -eq 0)
                    {
			            $vmDiskOutput = "
                <td>$vmDiskData</td>
            </tr>"
                        $rowSpanCount = $rowSpanCount + 1
                    }
                    else
                    {
                        $vmDiskOutput +="
            <tr style=""background:$($vmTableTrBgColor)"">
                <td Style=""border-top:2px dotted #ccc"">$vmDiskData</td>
            </tr>"
                        $rowSpanCount = $rowSpanCount + 1
                    }
                }
            }

            #If single VHD, rowSpanCount equal to 0 
            if ($rowSpanCount -eq 1)
            {
                $rowSpanCount = 0
            }

            # Data Line
            $chargerVmTable ="
            <tr style=""background:$($vmTableTrBgColor)""><!--Data Line-->
                <td rowspan=""$($rowSpanCount)""><p style=""text-align:left""><abbr title=""$($outVmPath)"">$($outVmName) <span style=""font-size:10px;color:orange"">*</span></abbr> $($outVmGenVer) <br/>ClusterResource:$($outVmIsClustered)</span></p></td>
                <td rowspan=""$($rowSpanCount)"" bgcolor=""$vmStateBgColor""><p style=""color:$($vmStateWordColor)"">$($outVmState)</p></td>
                <td rowspan=""$($rowSpanCount)""><p>$($outVmUptimeDays)$($outVmUptime)</p></td>
                <td rowspan=""$($rowSpanCount)""><p>$($outVmHost)</p></td>
                <td rowspan=""$($rowSpanCount)""><p style=""line-height:1.1"">$($outVmCPU)<br/><span style=""font-size:10px"">CPU</span></p></td>
                <td rowspan=""$($rowSpanCount)"" style=""border-right: 2px dotted #ccc""><p style=""line-height:1.1""><abbr title=""Startup Memory"">$($outVmMemStartup[0])<br/><span style=""font-size:10px"">$($outVmMemStartup[1])</span></abbr></p></td>
                <td rowspan=""$($rowSpanCount)"" style=""border-right: 2px dotted #ccc""><p style=""line-height:1.1""><abbr title=""Minimum Memory"">$($outVmMemMin[0])<br/><span style=""font-size:10px"">$($outVmMemMin[1])</span></abbr></p></td>
                <td rowspan=""$($rowSpanCount)"" style=""border-right: 2px dotted #ccc""><p style=""line-height:1.1""><abbr title=""Maximum Memory"">$($outVmMemMax[0])<br/><span style=""font-size:10px"">$($outVmMemMax[1])</span></abbr></p></td>
                <td rowspan=""$($rowSpanCount)""><p style=""line-height:1.1""><abbr title=""Assigned Memory"">$($outVmMemAssigned[0])<br/><span style=""font-size:10px"">$($outVmMemAssigned[1])</span></abbr></p></td>
                <td rowspan=""$($rowSpanCount)""><p style=""background-color:$($vmIsStateBgColor);color:$($vmIsStateWordColor)""><abbr title=""IS Version: $($outVmIsVer)"">$($outVmIs) <span style=""font-size:10px;color:orange"">*</span></abbr></p></td>
                <td rowspan=""$($rowSpanCount)""><p style=""background-color:$($vmCheckpointBgColor);color:$($vmCheckpointWordColor)""><abbr title=""$($outVmChekpointCount)"">$($outVmChekpoint)</abbr></p></td>
                <td rowspan=""$($rowSpanCount)""><p style=""background-color:$($vmReplHealthBgColor);color:$($vmReplHealthWordColor)""><abbr title=""$($outVMReplState)$($outVmReplReplicaServer)$($outVmReplFrequency)"">$($outVmReplHealth)</abbr></p></td>"
		        $chargerVmTable += $vmDiskOutput

            # Output Data
            if ($HighlightsOnly -eq $false)
            {
                $outVMTable += $chargerVmTable
                $vmNoInTable = $vmNoInTable + 1
            }
            elseif (($HighlightsOnly -eq $true) -and ($highL -eq $true))
            {      
                $outVMTable += $chargerVmTable
                $vmNoInTable = $vmNoInTable + 1
            }
            else
            {
                # Blank
            }
        }
    }
    # Error
    elseif ($getVMerr)
    {
        sPrint -Type 0 -Message "$($VMHost.ToUpper()): $($getVMerr.exception.message)" -WriteToLogFile $True
        sPrint -Type 2 -Message "Gathering VM Information for '$($VMHost.ToUpper())' failed." -WriteToLogFile $True
        Start-Sleep -Seconds 3
        Continue
    }
    else
    # Blank
    {
        sPrint -Type 2 -Message "$($VMHost.ToUpper()): Does not have Virtual Machine." -WriteToLogFile $True
        Start-Sleep -Seconds 3
    }

    # If detected clustered VM configuration resource problem
    if ($offlineVmConfigData)
    {
        ForEach ($offlineVmConfig in $offlineVmConfigData)
        {
            # Table TR Color
            if([bool]!($vmNoInTable%2))
            {
               #Even or Zero
               $vmTableTrBgColor = ""
            }
            else
            {
               #Odd
               $vmTableTrBgColor = "#F9F9F9"
            }

            $outVMTable +="
            <tr style=""background:$($vmTableTrBgColor)""><!--Data Line-->
                <td><p style=""text-align:left""><abbr title=""Virtual Machine Configuration resource is Offline"">$($offlineVmConfig.OwnerGroup) <span style=""font-size:10px;color:orange"">*</span></abbr> <br/><span style=""font-size:10px;color:#BDBDBD"">ClusterResource:Yes</span></p></td>
                <td bgcolor=""$($stateBgColors[3])""><p style=""color:$($stateWordColors[3])"">Offline</p></td>
                <td><p>-</p></td>
                <td><p>$outVmHost</p></td>
                <td><p>-</p></td>
                <td style=""border-right: 2px dotted #ccc""><p>-</p></td>
                <td style=""border-right: 2px dotted #ccc""><p>-</p></td>
                <td style=""border-right: 2px dotted #ccc""><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p>-</p></td>
                <td><p style=""text-align:left""><span style=""background-color:$($stateBgColors[3]);color:$($stateWordColors[3])"">&nbsp;Virtual Machine cluster configuration resource is offline&nbsp;</span></p></td>
            </tr>"

            $vmNoInTable = $vmNoInTable + 1
        }
    }
}

if (($HighlightsOnly -eq $true) -and ($outVmTable -eq $null) -and ($cntVM -ne 0))
{
    $outVmTable +="
            <tr><!--Data Line-->
                <td colspan=""13""><p style=""text-align:center""><span style=""padding-top:1px;padding-bottom:1px;background-color:#ACFA58;color:#298A08"">&nbsp;&nbsp;All VMs are healthy&nbsp;&nbsp;</span></p></td>
            </tr>"
}

if (($outVmTable -eq $null) -and ($cntVM -eq 0))
{
    $outVmTable +="
            <tr><!--Data Line-->
                <td colspan=""13""><p style=""text-align:center""><span style=""color:#BDBDBD"">No virtual machine for reporting</span></p></td>
            </tr>"
}

# VMs Table - End
$outVMTableEnd ="
        </tbody>
        </table>
    </div><!--End VMs Class-->"

#endregion

#region HTML End
#---------------

$outHtmlEnd ="
</div><!--End ReportBody-->
<center><p style=""font-size:12px;color:#BDBDBD"">ScriptVersion: 1.0 | CreatedBy: Serhat AKINCI - Hyper-V MVP - @serhatakinci | Feedback: serhatakinci@gmail.com</p></center>
<br/>
</body>
</html>"

# Print MSG
sPrint -Type 1 -Message "Writing output to file $ReportFile" -WriteToLogFile $True

$outFullHTML = $outHtmlStart + $outVMHostTableStart + $outVMHostTable + $outVMHostTableEnd + $outVolumeTableStart + $outVolumeTable + $outVolumeTableEnd + $outVMTableStart + $outVMTable + $outVMTableEnd + $outHtmlEnd

$outFullHTML | Out-File $ReportFile

if (Test-Path -Path $ReportFile)
{
    sPrint -Type 1 -Message "Report created successfully." -WriteToLogFile $True
}
else
{
    sPrint -Type 2 -Message "Reporting file could not be created. Please review the log file." -WriteToLogFile $True
}

#endregion

#region Send Mail
#---------------

if ($SendMail -or $SMTPServer)
{
    if ($SMTPServer -and $MailFrom -and $MailTo)
    {

        sPrint -Type 1 -Message "Sending e-mail..." -WriteToLogFile $True

        $subject = "Hyper-V Environment Report"
        $attachment = $ReportFile
        $MailTo = ($MailTo -join ',').ToString()
        $mailMessage = New-Object System.Net.Mail.MailMessage
        $mailMessage.subject = $subject
        $mailMessage.to.add($MailTo)
        $mailMessage.from = $MailFrom
        $mailMessage.attachments.add($attachment)
        $smtp = New-Object System.Net.Mail.SmtpClient($SMTPServer, $SMTPPort);

        if ($MailFromPassword)
        {
            $smtp.UseDefaultCredentials = $false
            $smtp.Credentials = New-Object System.Net.NetworkCredential($MailFrom, $MailFromPassword);
        }
        
        if ($SMTPServerTLSorSSL)
        {
            $smtp.EnableSSL = $true
        }
        
        $smtpSendResult = 1
        Try
        {
            $smtp.send($mailMessage)
        }
        Catch
        {
            sPrint -Type 0 -Message "E-Mail could not be sent: $($_.Exception.Message)" -WriteToLogFile $True
            $smtpSendResult = 0
        }

        if ($smtpSendResult -eq 1)
        {
            sPrint -Type 1 -Message "E-mail has been sent to the address(es): $MailTo" -WriteToLogFile $True
        }

        Remove-Variable -Name smtp
        Remove-Variable -Name MailFromPassword
    }
    else
    {
        sPrint -Type 0 -Message "Missing parameter(s): -SMTPServer and(or) -MailFrom and(or) -MailTo" -WriteToLogFile $True
    }
}

sPrint -Type 1 "Completed!" -WriteToLogFile $True
sPrint -Type 5 -Message "----- End   -----" -WriteToLogFile $true

#endregion
